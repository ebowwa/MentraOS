// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: mentraos_ble.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// All messages from phone to glasses
struct Mentraos_Ble_PhoneToGlasses: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional message ID for request/response correlation
  var msgID: String = String()

  var payload: Mentraos_Ble_PhoneToGlasses.OneOf_Payload? = nil

  /// Connection Management
  var disconnect: Mentraos_Ble_DisconnectRequest {
    get {
      if case .disconnect(let v)? = payload {return v}
      return Mentraos_Ble_DisconnectRequest()
    }
    set {payload = .disconnect(newValue)}
  }

  var batteryState: Mentraos_Ble_BatteryStateRequest {
    get {
      if case .batteryState(let v)? = payload {return v}
      return Mentraos_Ble_BatteryStateRequest()
    }
    set {payload = .batteryState(newValue)}
  }

  var glassesInfo: Mentraos_Ble_GlassesInfoRequest {
    get {
      if case .glassesInfo(let v)? = payload {return v}
      return Mentraos_Ble_GlassesInfoRequest()
    }
    set {payload = .glassesInfo(newValue)}
  }

  var pairingMode: Mentraos_Ble_PairingModeRequest {
    get {
      if case .pairingMode(let v)? = payload {return v}
      return Mentraos_Ble_PairingModeRequest()
    }
    set {payload = .pairingMode(newValue)}
  }

  var headPosition: Mentraos_Ble_HeadPositionRequest {
    get {
      if case .headPosition(let v)? = payload {return v}
      return Mentraos_Ble_HeadPositionRequest()
    }
    set {payload = .headPosition(newValue)}
  }

  var headUpAngle: Mentraos_Ble_HeadUpAngleConfig {
    get {
      if case .headUpAngle(let v)? = payload {return v}
      return Mentraos_Ble_HeadUpAngleConfig()
    }
    set {payload = .headUpAngle(newValue)}
  }

  var ping: Mentraos_Ble_PingRequest {
    get {
      if case .ping(let v)? = payload {return v}
      return Mentraos_Ble_PingRequest()
    }
    set {payload = .ping(newValue)}
  }

  /// Audio System
  var micState: Mentraos_Ble_MicStateConfig {
    get {
      if case .micState(let v)? = payload {return v}
      return Mentraos_Ble_MicStateConfig()
    }
    set {payload = .micState(newValue)}
  }

  var vadEnabled: Mentraos_Ble_VadEnabledConfig {
    get {
      if case .vadEnabled(let v)? = payload {return v}
      return Mentraos_Ble_VadEnabledConfig()
    }
    set {payload = .vadEnabled(newValue)}
  }

  var vadConfig: Mentraos_Ble_VadConfig {
    get {
      if case .vadConfig(let v)? = payload {return v}
      return Mentraos_Ble_VadConfig()
    }
    set {payload = .vadConfig(newValue)}
  }

  /// Display System
  var displayText: Mentraos_Ble_DisplayText {
    get {
      if case .displayText(let v)? = payload {return v}
      return Mentraos_Ble_DisplayText()
    }
    set {payload = .displayText(newValue)}
  }

  var displayImage: Mentraos_Ble_DisplayImage {
    get {
      if case .displayImage(let v)? = payload {return v}
      return Mentraos_Ble_DisplayImage()
    }
    set {payload = .displayImage(newValue)}
  }

  var preloadImage: Mentraos_Ble_PreloadImage {
    get {
      if case .preloadImage(let v)? = payload {return v}
      return Mentraos_Ble_PreloadImage()
    }
    set {payload = .preloadImage(newValue)}
  }

  var displayCachedImage: Mentraos_Ble_DisplayCachedImage {
    get {
      if case .displayCachedImage(let v)? = payload {return v}
      return Mentraos_Ble_DisplayCachedImage()
    }
    set {payload = .displayCachedImage(newValue)}
  }

  var clearCachedImage_p: Mentraos_Ble_ClearCachedImage {
    get {
      if case .clearCachedImage_p(let v)? = payload {return v}
      return Mentraos_Ble_ClearCachedImage()
    }
    set {payload = .clearCachedImage_p(newValue)}
  }

  var displayScrollingText: Mentraos_Ble_DisplayScrollingText {
    get {
      if case .displayScrollingText(let v)? = payload {return v}
      return Mentraos_Ble_DisplayScrollingText()
    }
    set {payload = .displayScrollingText(newValue)}
  }

  var displayPower: Mentraos_Ble_DisplayPowerConfig {
    get {
      if case .displayPower(let v)? = payload {return v}
      return Mentraos_Ble_DisplayPowerConfig()
    }
    set {payload = .displayPower(newValue)}
  }

  var brightness: Mentraos_Ble_BrightnessConfig {
    get {
      if case .brightness(let v)? = payload {return v}
      return Mentraos_Ble_BrightnessConfig()
    }
    set {payload = .brightness(newValue)}
  }

  var autoBrightness: Mentraos_Ble_AutoBrightnessConfig {
    get {
      if case .autoBrightness(let v)? = payload {return v}
      return Mentraos_Ble_AutoBrightnessConfig()
    }
    set {payload = .autoBrightness(newValue)}
  }

  var autoBrightnessMult: Mentraos_Ble_AutoBrightnessMultiplier {
    get {
      if case .autoBrightnessMult(let v)? = payload {return v}
      return Mentraos_Ble_AutoBrightnessMultiplier()
    }
    set {payload = .autoBrightnessMult(newValue)}
  }

  var drawLine: Mentraos_Ble_DrawLine {
    get {
      if case .drawLine(let v)? = payload {return v}
      return Mentraos_Ble_DrawLine()
    }
    set {payload = .drawLine(newValue)}
  }

  var drawRect: Mentraos_Ble_DrawRect {
    get {
      if case .drawRect(let v)? = payload {return v}
      return Mentraos_Ble_DrawRect()
    }
    set {payload = .drawRect(newValue)}
  }

  var drawCircle: Mentraos_Ble_DrawCircle {
    get {
      if case .drawCircle(let v)? = payload {return v}
      return Mentraos_Ble_DrawCircle()
    }
    set {payload = .drawCircle(newValue)}
  }

  var commit: Mentraos_Ble_CommitDisplay {
    get {
      if case .commit(let v)? = payload {return v}
      return Mentraos_Ble_CommitDisplay()
    }
    set {payload = .commit(newValue)}
  }

  var displayDistance: Mentraos_Ble_DisplayDistanceConfig {
    get {
      if case .displayDistance(let v)? = payload {return v}
      return Mentraos_Ble_DisplayDistanceConfig()
    }
    set {payload = .displayDistance(newValue)}
  }

  var displayHeight: Mentraos_Ble_DisplayHeightConfig {
    get {
      if case .displayHeight(let v)? = payload {return v}
      return Mentraos_Ble_DisplayHeightConfig()
    }
    set {payload = .displayHeight(newValue)}
  }

  /// User Input
  var imuEnabled: Mentraos_Ble_ImuEnabledConfig {
    get {
      if case .imuEnabled(let v)? = payload {return v}
      return Mentraos_Ble_ImuEnabledConfig()
    }
    set {payload = .imuEnabled(newValue)}
  }

  var imuSingle: Mentraos_Ble_ImuSingleRequest {
    get {
      if case .imuSingle(let v)? = payload {return v}
      return Mentraos_Ble_ImuSingleRequest()
    }
    set {payload = .imuSingle(newValue)}
  }

  var imuStream: Mentraos_Ble_ImuStreamConfig {
    get {
      if case .imuStream(let v)? = payload {return v}
      return Mentraos_Ble_ImuStreamConfig()
    }
    set {payload = .imuStream(newValue)}
  }

  var headGesture: Mentraos_Ble_HeadGestureConfig {
    get {
      if case .headGesture(let v)? = payload {return v}
      return Mentraos_Ble_HeadGestureConfig()
    }
    set {payload = .headGesture(newValue)}
  }

  /// System Control
  var restart: Mentraos_Ble_RestartRequest {
    get {
      if case .restart(let v)? = payload {return v}
      return Mentraos_Ble_RestartRequest()
    }
    set {payload = .restart(newValue)}
  }

  var factoryReset: Mentraos_Ble_FactoryResetRequest {
    get {
      if case .factoryReset(let v)? = payload {return v}
      return Mentraos_Ble_FactoryResetRequest()
    }
    set {payload = .factoryReset(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Payload: Equatable, Sendable {
    /// Connection Management
    case disconnect(Mentraos_Ble_DisconnectRequest)
    case batteryState(Mentraos_Ble_BatteryStateRequest)
    case glassesInfo(Mentraos_Ble_GlassesInfoRequest)
    case pairingMode(Mentraos_Ble_PairingModeRequest)
    case headPosition(Mentraos_Ble_HeadPositionRequest)
    case headUpAngle(Mentraos_Ble_HeadUpAngleConfig)
    case ping(Mentraos_Ble_PingRequest)
    /// Audio System
    case micState(Mentraos_Ble_MicStateConfig)
    case vadEnabled(Mentraos_Ble_VadEnabledConfig)
    case vadConfig(Mentraos_Ble_VadConfig)
    /// Display System
    case displayText(Mentraos_Ble_DisplayText)
    case displayImage(Mentraos_Ble_DisplayImage)
    case preloadImage(Mentraos_Ble_PreloadImage)
    case displayCachedImage(Mentraos_Ble_DisplayCachedImage)
    case clearCachedImage_p(Mentraos_Ble_ClearCachedImage)
    case displayScrollingText(Mentraos_Ble_DisplayScrollingText)
    case displayPower(Mentraos_Ble_DisplayPowerConfig)
    case brightness(Mentraos_Ble_BrightnessConfig)
    case autoBrightness(Mentraos_Ble_AutoBrightnessConfig)
    case autoBrightnessMult(Mentraos_Ble_AutoBrightnessMultiplier)
    case drawLine(Mentraos_Ble_DrawLine)
    case drawRect(Mentraos_Ble_DrawRect)
    case drawCircle(Mentraos_Ble_DrawCircle)
    case commit(Mentraos_Ble_CommitDisplay)
    case displayDistance(Mentraos_Ble_DisplayDistanceConfig)
    case displayHeight(Mentraos_Ble_DisplayHeightConfig)
    /// User Input
    case imuEnabled(Mentraos_Ble_ImuEnabledConfig)
    case imuSingle(Mentraos_Ble_ImuSingleRequest)
    case imuStream(Mentraos_Ble_ImuStreamConfig)
    case headGesture(Mentraos_Ble_HeadGestureConfig)
    /// System Control
    case restart(Mentraos_Ble_RestartRequest)
    case factoryReset(Mentraos_Ble_FactoryResetRequest)

  }

  init() {}
}

/// All messages from glasses to phone
struct Mentraos_Ble_GlassesToPhone: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var payload: Mentraos_Ble_GlassesToPhone.OneOf_Payload? = nil

  /// Connection Management
  var batteryStatus: Mentraos_Ble_BatteryStatus {
    get {
      if case .batteryStatus(let v)? = payload {return v}
      return Mentraos_Ble_BatteryStatus()
    }
    set {payload = .batteryStatus(newValue)}
  }

  var chargingState: Mentraos_Ble_ChargingState {
    get {
      if case .chargingState(let v)? = payload {return v}
      return Mentraos_Ble_ChargingState()
    }
    set {payload = .chargingState(newValue)}
  }

  var deviceInfo: Mentraos_Ble_DeviceInfo {
    get {
      if case .deviceInfo(let v)? = payload {return v}
      return Mentraos_Ble_DeviceInfo()
    }
    set {payload = .deviceInfo(newValue)}
  }

  var headPosition: Mentraos_Ble_HeadPosition {
    get {
      if case .headPosition(let v)? = payload {return v}
      return Mentraos_Ble_HeadPosition()
    }
    set {payload = .headPosition(newValue)}
  }

  var headUpAngleSet: Mentraos_Ble_HeadUpAngleResponse {
    get {
      if case .headUpAngleSet(let v)? = payload {return v}
      return Mentraos_Ble_HeadUpAngleResponse()
    }
    set {payload = .headUpAngleSet(newValue)}
  }

  var pong: Mentraos_Ble_PongResponse {
    get {
      if case .pong(let v)? = payload {return v}
      return Mentraos_Ble_PongResponse()
    }
    set {payload = .pong(newValue)}
  }

  /// Audio System
  var vadEvent: Mentraos_Ble_VadEvent {
    get {
      if case .vadEvent(let v)? = payload {return v}
      return Mentraos_Ble_VadEvent()
    }
    set {payload = .vadEvent(newValue)}
  }

  /// Display System  
  var imageTransferComplete: Mentraos_Ble_ImageTransferComplete {
    get {
      if case .imageTransferComplete(let v)? = payload {return v}
      return Mentraos_Ble_ImageTransferComplete()
    }
    set {payload = .imageTransferComplete(newValue)}
  }

  /// User Input
  var imuData: Mentraos_Ble_ImuData {
    get {
      if case .imuData(let v)? = payload {return v}
      return Mentraos_Ble_ImuData()
    }
    set {payload = .imuData(newValue)}
  }

  var buttonEvent: Mentraos_Ble_ButtonEvent {
    get {
      if case .buttonEvent(let v)? = payload {return v}
      return Mentraos_Ble_ButtonEvent()
    }
    set {payload = .buttonEvent(newValue)}
  }

  var headGesture: Mentraos_Ble_HeadGesture {
    get {
      if case .headGesture(let v)? = payload {return v}
      return Mentraos_Ble_HeadGesture()
    }
    set {payload = .headGesture(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Payload: Equatable, Sendable {
    /// Connection Management
    case batteryStatus(Mentraos_Ble_BatteryStatus)
    case chargingState(Mentraos_Ble_ChargingState)
    case deviceInfo(Mentraos_Ble_DeviceInfo)
    case headPosition(Mentraos_Ble_HeadPosition)
    case headUpAngleSet(Mentraos_Ble_HeadUpAngleResponse)
    case pong(Mentraos_Ble_PongResponse)
    /// Audio System
    case vadEvent(Mentraos_Ble_VadEvent)
    /// Display System  
    case imageTransferComplete(Mentraos_Ble_ImageTransferComplete)
    /// User Input
    case imuData(Mentraos_Ble_ImuData)
    case buttonEvent(Mentraos_Ble_ButtonEvent)
    case headGesture(Mentraos_Ble_HeadGesture)

  }

  init() {}
}

struct Mentraos_Ble_DisconnectRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_BatteryStateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_BatteryStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 0-100 percentage
  var level: UInt32 = 0

  var charging: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_ChargingState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var state: Mentraos_Ble_ChargingState.State = .notCharging

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case notCharging // = 0
    case charging // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .notCharging
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .notCharging
      case 1: self = .charging
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .notCharging: return 0
      case .charging: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Mentraos_Ble_ChargingState.State] = [
      .notCharging,
      .charging,
    ]

  }

  init() {}
}

struct Mentraos_Ble_GlassesInfoRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_DeviceInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fwVersion: String = String()

  var hwModel: String = String()

  var features: Mentraos_Ble_DeviceFeatures {
    get {return _features ?? Mentraos_Ble_DeviceFeatures()}
    set {_features = newValue}
  }
  /// Returns true if `features` has been explicitly set.
  var hasFeatures: Bool {return self._features != nil}
  /// Clears the value of `features`. Subsequent reads from it will return its default value.
  mutating func clearFeatures() {self._features = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _features: Mentraos_Ble_DeviceFeatures? = nil
}

struct Mentraos_Ble_DeviceFeatures: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var camera: Bool = false

  var display: Bool = false

  var audioTx: Bool = false

  var audioRx: Bool = false

  var imu: Bool = false

  var vad: Bool = false

  var micSwitching: Bool = false

  /// Max chunks that can be buffered
  var imageChunkBuffer: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_PairingModeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_HeadPositionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_HeadPosition: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// degrees
  var angle: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_HeadUpAngleConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// degrees
  var angle: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_HeadUpAngleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_PingRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_PongResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_MicStateConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_VadEnabledConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_VadConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 0-100
  var sensitivity: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_VadEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var state: Mentraos_Ble_VadEvent.State = .inactive

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case inactive // = 0
    case active // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .inactive
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .inactive
      case 1: self = .active
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .inactive: return 0
      case .active: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Mentraos_Ble_VadEvent.State] = [
      .inactive,
      .active,
    ]

  }

  init() {}
}

struct Mentraos_Ble_DisplayText: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var text: String = String()

  /// RGB565 format (e.g., 0xF800 for red)
  var color: UInt32 = 0

  /// Font identifier
  var fontCode: UInt32 = 0

  var x: UInt32 = 0

  var y: UInt32 = 0

  /// Font size multiplier
  var size: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Initiates bitmap transfer - actual data comes via binary protocol
struct Mentraos_Ble_DisplayImage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 2-byte hex string like "002A"
  var streamID: String = String()

  var x: UInt32 = 0

  var y: UInt32 = 0

  var width: UInt32 = 0

  var height: UInt32 = 0

  /// "rle", "webp", etc.
  var encoding: String = String()

  var totalChunks: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_PreloadImage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var streamID: String = String()

  /// ID for later reference
  var imageID: UInt32 = 0

  var width: UInt32 = 0

  var height: UInt32 = 0

  var encoding: String = String()

  var totalChunks: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_DisplayCachedImage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var imageID: UInt32 = 0

  var x: UInt32 = 0

  var y: UInt32 = 0

  var width: UInt32 = 0

  var height: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_ClearCachedImage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var imageID: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_DisplayScrollingText: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var text: String = String()

  var color: UInt32 = 0

  var fontCode: UInt32 = 0

  var x: UInt32 = 0

  var y: UInt32 = 0

  var width: UInt32 = 0

  var height: UInt32 = 0

  var align: Mentraos_Ble_DisplayScrollingText.Alignment = .left

  /// pixels between lines
  var lineSpacing: UInt32 = 0

  /// pixels/sec scrolling up
  var speed: UInt32 = 0

  /// font size multiplier
  var size: UInt32 = 0

  /// wrap to top when finished
  var loop: Bool = false

  /// delay before restart (if looping)
  var pauseMs: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Alignment: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case left // = 0
    case center // = 1
    case right // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .left
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .left
      case 1: self = .center
      case 2: self = .right
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .left: return 0
      case .center: return 1
      case .right: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Mentraos_Ble_DisplayScrollingText.Alignment] = [
      .left,
      .center,
      .right,
    ]

  }

  init() {}
}

struct Mentraos_Ble_DisplayPowerConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// true = turn on, false = turn off
  var on: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_BrightnessConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 0-100
  var value: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_AutoBrightnessConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_AutoBrightnessMultiplier: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// e.g., 0.8 = 80%
  var multiplier: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_DrawLine: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var color: UInt32 = 0

  var stroke: UInt32 = 0

  var x1: UInt32 = 0

  var y1: UInt32 = 0

  var x2: UInt32 = 0

  var y2: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_DrawRect: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var color: UInt32 = 0

  var stroke: UInt32 = 0

  var x: UInt32 = 0

  var y: UInt32 = 0

  var width: UInt32 = 0

  var height: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_DrawCircle: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var color: UInt32 = 0

  var stroke: UInt32 = 0

  var x: UInt32 = 0

  var y: UInt32 = 0

  var radius: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_CommitDisplay: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_DisplayDistanceConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var distanceCm: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_DisplayHeightConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var height: UInt32 = 0

  var depth: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_ImageTransferComplete: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var streamID: String = String()

  var status: Mentraos_Ble_ImageTransferComplete.Status = .ok

  /// List of missing chunk indices
  var missingChunks: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case ok // = 0
    case incomplete // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .incomplete
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .incomplete: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Mentraos_Ble_ImageTransferComplete.Status] = [
      .ok,
      .incomplete,
    ]

  }

  init() {}
}

struct Mentraos_Ble_ImuEnabledConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_ImuSingleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_ImuStreamConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_ImuData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accel: Mentraos_Ble_Vector3 {
    get {return _accel ?? Mentraos_Ble_Vector3()}
    set {_accel = newValue}
  }
  /// Returns true if `accel` has been explicitly set.
  var hasAccel: Bool {return self._accel != nil}
  /// Clears the value of `accel`. Subsequent reads from it will return its default value.
  mutating func clearAccel() {self._accel = nil}

  var gyro: Mentraos_Ble_Vector3 {
    get {return _gyro ?? Mentraos_Ble_Vector3()}
    set {_gyro = newValue}
  }
  /// Returns true if `gyro` has been explicitly set.
  var hasGyro: Bool {return self._gyro != nil}
  /// Clears the value of `gyro`. Subsequent reads from it will return its default value.
  mutating func clearGyro() {self._gyro = nil}

  var mag: Mentraos_Ble_Vector3 {
    get {return _mag ?? Mentraos_Ble_Vector3()}
    set {_mag = newValue}
  }
  /// Returns true if `mag` has been explicitly set.
  var hasMag: Bool {return self._mag != nil}
  /// Clears the value of `mag`. Subsequent reads from it will return its default value.
  mutating func clearMag() {self._mag = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _accel: Mentraos_Ble_Vector3? = nil
  fileprivate var _gyro: Mentraos_Ble_Vector3? = nil
  fileprivate var _mag: Mentraos_Ble_Vector3? = nil
}

struct Mentraos_Ble_Vector3: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Float = 0

  var y: Float = 0

  var z: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_ButtonEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var button: Mentraos_Ble_ButtonEvent.Button = .center

  var state: Mentraos_Ble_ButtonEvent.State = .up

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Button: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case center // = 0
    case left // = 1
    case right // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .center
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .center
      case 1: self = .left
      case 2: self = .right
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .center: return 0
      case .left: return 1
      case .right: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Mentraos_Ble_ButtonEvent.Button] = [
      .center,
      .left,
      .right,
    ]

  }

  enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case up // = 0
    case down // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .up
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .up
      case 1: self = .down
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .up: return 0
      case .down: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Mentraos_Ble_ButtonEvent.State] = [
      .up,
      .down,
    ]

  }

  init() {}
}

struct Mentraos_Ble_HeadGesture: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gesture: Mentraos_Ble_HeadGesture.Gesture = .nod

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Gesture: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case nod // = 0
    case shake // = 1
    case headUp // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .nod
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .nod
      case 1: self = .shake
      case 2: self = .headUp
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .nod: return 0
      case .shake: return 1
      case .headUp: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Mentraos_Ble_HeadGesture.Gesture] = [
      .nod,
      .shake,
      .headUp,
    ]

  }

  init() {}
}

struct Mentraos_Ble_HeadGestureConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gesture: Mentraos_Ble_HeadGesture.Gesture = .nod

  var enabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_RestartRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_FactoryResetRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "mentraos.ble"

extension Mentraos_Ble_PhoneToGlasses: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PhoneToGlasses"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "msg_id"),
    10: .same(proto: "disconnect"),
    11: .standard(proto: "battery_state"),
    12: .standard(proto: "glasses_info"),
    13: .standard(proto: "pairing_mode"),
    14: .standard(proto: "head_position"),
    15: .standard(proto: "head_up_angle"),
    16: .same(proto: "ping"),
    20: .standard(proto: "mic_state"),
    21: .standard(proto: "vad_enabled"),
    22: .standard(proto: "vad_config"),
    30: .standard(proto: "display_text"),
    31: .standard(proto: "display_image"),
    32: .standard(proto: "preload_image"),
    33: .standard(proto: "display_cached_image"),
    34: .standard(proto: "clear_cached_image"),
    35: .standard(proto: "display_scrolling_text"),
    36: .standard(proto: "display_power"),
    37: .same(proto: "brightness"),
    38: .standard(proto: "auto_brightness"),
    39: .standard(proto: "auto_brightness_mult"),
    40: .standard(proto: "draw_line"),
    41: .standard(proto: "draw_rect"),
    42: .standard(proto: "draw_circle"),
    43: .same(proto: "commit"),
    44: .standard(proto: "display_distance"),
    45: .standard(proto: "display_height"),
    50: .standard(proto: "imu_enabled"),
    51: .standard(proto: "imu_single"),
    52: .standard(proto: "imu_stream"),
    53: .standard(proto: "head_gesture"),
    60: .same(proto: "restart"),
    61: .standard(proto: "factory_reset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.msgID) }()
      case 10: try {
        var v: Mentraos_Ble_DisconnectRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .disconnect(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .disconnect(v)
        }
      }()
      case 11: try {
        var v: Mentraos_Ble_BatteryStateRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .batteryState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .batteryState(v)
        }
      }()
      case 12: try {
        var v: Mentraos_Ble_GlassesInfoRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .glassesInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .glassesInfo(v)
        }
      }()
      case 13: try {
        var v: Mentraos_Ble_PairingModeRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .pairingMode(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .pairingMode(v)
        }
      }()
      case 14: try {
        var v: Mentraos_Ble_HeadPositionRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .headPosition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .headPosition(v)
        }
      }()
      case 15: try {
        var v: Mentraos_Ble_HeadUpAngleConfig?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .headUpAngle(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .headUpAngle(v)
        }
      }()
      case 16: try {
        var v: Mentraos_Ble_PingRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .ping(v)
        }
      }()
      case 20: try {
        var v: Mentraos_Ble_MicStateConfig?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .micState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .micState(v)
        }
      }()
      case 21: try {
        var v: Mentraos_Ble_VadEnabledConfig?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .vadEnabled(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .vadEnabled(v)
        }
      }()
      case 22: try {
        var v: Mentraos_Ble_VadConfig?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .vadConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .vadConfig(v)
        }
      }()
      case 30: try {
        var v: Mentraos_Ble_DisplayText?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .displayText(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .displayText(v)
        }
      }()
      case 31: try {
        var v: Mentraos_Ble_DisplayImage?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .displayImage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .displayImage(v)
        }
      }()
      case 32: try {
        var v: Mentraos_Ble_PreloadImage?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .preloadImage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .preloadImage(v)
        }
      }()
      case 33: try {
        var v: Mentraos_Ble_DisplayCachedImage?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .displayCachedImage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .displayCachedImage(v)
        }
      }()
      case 34: try {
        var v: Mentraos_Ble_ClearCachedImage?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .clearCachedImage_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .clearCachedImage_p(v)
        }
      }()
      case 35: try {
        var v: Mentraos_Ble_DisplayScrollingText?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .displayScrollingText(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .displayScrollingText(v)
        }
      }()
      case 36: try {
        var v: Mentraos_Ble_DisplayPowerConfig?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .displayPower(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .displayPower(v)
        }
      }()
      case 37: try {
        var v: Mentraos_Ble_BrightnessConfig?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .brightness(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .brightness(v)
        }
      }()
      case 38: try {
        var v: Mentraos_Ble_AutoBrightnessConfig?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .autoBrightness(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .autoBrightness(v)
        }
      }()
      case 39: try {
        var v: Mentraos_Ble_AutoBrightnessMultiplier?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .autoBrightnessMult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .autoBrightnessMult(v)
        }
      }()
      case 40: try {
        var v: Mentraos_Ble_DrawLine?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .drawLine(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .drawLine(v)
        }
      }()
      case 41: try {
        var v: Mentraos_Ble_DrawRect?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .drawRect(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .drawRect(v)
        }
      }()
      case 42: try {
        var v: Mentraos_Ble_DrawCircle?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .drawCircle(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .drawCircle(v)
        }
      }()
      case 43: try {
        var v: Mentraos_Ble_CommitDisplay?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .commit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .commit(v)
        }
      }()
      case 44: try {
        var v: Mentraos_Ble_DisplayDistanceConfig?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .displayDistance(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .displayDistance(v)
        }
      }()
      case 45: try {
        var v: Mentraos_Ble_DisplayHeightConfig?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .displayHeight(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .displayHeight(v)
        }
      }()
      case 50: try {
        var v: Mentraos_Ble_ImuEnabledConfig?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .imuEnabled(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .imuEnabled(v)
        }
      }()
      case 51: try {
        var v: Mentraos_Ble_ImuSingleRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .imuSingle(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .imuSingle(v)
        }
      }()
      case 52: try {
        var v: Mentraos_Ble_ImuStreamConfig?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .imuStream(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .imuStream(v)
        }
      }()
      case 53: try {
        var v: Mentraos_Ble_HeadGestureConfig?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .headGesture(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .headGesture(v)
        }
      }()
      case 60: try {
        var v: Mentraos_Ble_RestartRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .restart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .restart(v)
        }
      }()
      case 61: try {
        var v: Mentraos_Ble_FactoryResetRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .factoryReset(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .factoryReset(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.msgID.isEmpty {
      try visitor.visitSingularStringField(value: self.msgID, fieldNumber: 1)
    }
    switch self.payload {
    case .disconnect?: try {
      guard case .disconnect(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .batteryState?: try {
      guard case .batteryState(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .glassesInfo?: try {
      guard case .glassesInfo(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .pairingMode?: try {
      guard case .pairingMode(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .headPosition?: try {
      guard case .headPosition(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .headUpAngle?: try {
      guard case .headUpAngle(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .ping?: try {
      guard case .ping(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .micState?: try {
      guard case .micState(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .vadEnabled?: try {
      guard case .vadEnabled(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .vadConfig?: try {
      guard case .vadConfig(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .displayText?: try {
      guard case .displayText(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .displayImage?: try {
      guard case .displayImage(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case .preloadImage?: try {
      guard case .preloadImage(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case .displayCachedImage?: try {
      guard case .displayCachedImage(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
    }()
    case .clearCachedImage_p?: try {
      guard case .clearCachedImage_p(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
    }()
    case .displayScrollingText?: try {
      guard case .displayScrollingText(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
    }()
    case .displayPower?: try {
      guard case .displayPower(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
    }()
    case .brightness?: try {
      guard case .brightness(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
    }()
    case .autoBrightness?: try {
      guard case .autoBrightness(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
    }()
    case .autoBrightnessMult?: try {
      guard case .autoBrightnessMult(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
    }()
    case .drawLine?: try {
      guard case .drawLine(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
    }()
    case .drawRect?: try {
      guard case .drawRect(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
    }()
    case .drawCircle?: try {
      guard case .drawCircle(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
    }()
    case .commit?: try {
      guard case .commit(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
    }()
    case .displayDistance?: try {
      guard case .displayDistance(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
    }()
    case .displayHeight?: try {
      guard case .displayHeight(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
    }()
    case .imuEnabled?: try {
      guard case .imuEnabled(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
    }()
    case .imuSingle?: try {
      guard case .imuSingle(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
    }()
    case .imuStream?: try {
      guard case .imuStream(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
    }()
    case .headGesture?: try {
      guard case .headGesture(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
    }()
    case .restart?: try {
      guard case .restart(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 60)
    }()
    case .factoryReset?: try {
      guard case .factoryReset(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_PhoneToGlasses, rhs: Mentraos_Ble_PhoneToGlasses) -> Bool {
    if lhs.msgID != rhs.msgID {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_GlassesToPhone: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GlassesToPhone"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    10: .standard(proto: "battery_status"),
    11: .standard(proto: "charging_state"),
    12: .standard(proto: "device_info"),
    13: .standard(proto: "head_position"),
    14: .standard(proto: "head_up_angle_set"),
    15: .same(proto: "pong"),
    20: .standard(proto: "vad_event"),
    30: .standard(proto: "image_transfer_complete"),
    40: .standard(proto: "imu_data"),
    41: .standard(proto: "button_event"),
    42: .standard(proto: "head_gesture"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 10: try {
        var v: Mentraos_Ble_BatteryStatus?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .batteryStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .batteryStatus(v)
        }
      }()
      case 11: try {
        var v: Mentraos_Ble_ChargingState?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .chargingState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .chargingState(v)
        }
      }()
      case 12: try {
        var v: Mentraos_Ble_DeviceInfo?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .deviceInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .deviceInfo(v)
        }
      }()
      case 13: try {
        var v: Mentraos_Ble_HeadPosition?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .headPosition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .headPosition(v)
        }
      }()
      case 14: try {
        var v: Mentraos_Ble_HeadUpAngleResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .headUpAngleSet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .headUpAngleSet(v)
        }
      }()
      case 15: try {
        var v: Mentraos_Ble_PongResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .pong(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .pong(v)
        }
      }()
      case 20: try {
        var v: Mentraos_Ble_VadEvent?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .vadEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .vadEvent(v)
        }
      }()
      case 30: try {
        var v: Mentraos_Ble_ImageTransferComplete?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .imageTransferComplete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .imageTransferComplete(v)
        }
      }()
      case 40: try {
        var v: Mentraos_Ble_ImuData?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .imuData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .imuData(v)
        }
      }()
      case 41: try {
        var v: Mentraos_Ble_ButtonEvent?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .buttonEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .buttonEvent(v)
        }
      }()
      case 42: try {
        var v: Mentraos_Ble_HeadGesture?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .headGesture(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .headGesture(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .batteryStatus?: try {
      guard case .batteryStatus(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .chargingState?: try {
      guard case .chargingState(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .deviceInfo?: try {
      guard case .deviceInfo(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .headPosition?: try {
      guard case .headPosition(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .headUpAngleSet?: try {
      guard case .headUpAngleSet(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .pong?: try {
      guard case .pong(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .vadEvent?: try {
      guard case .vadEvent(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .imageTransferComplete?: try {
      guard case .imageTransferComplete(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .imuData?: try {
      guard case .imuData(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
    }()
    case .buttonEvent?: try {
      guard case .buttonEvent(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
    }()
    case .headGesture?: try {
      guard case .headGesture(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_GlassesToPhone, rhs: Mentraos_Ble_GlassesToPhone) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_DisconnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisconnectRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_DisconnectRequest, rhs: Mentraos_Ble_DisconnectRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_BatteryStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatteryStateRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_BatteryStateRequest, rhs: Mentraos_Ble_BatteryStateRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_BatteryStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatteryStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "level"),
    2: .same(proto: "charging"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.level) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.charging) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.level != 0 {
      try visitor.visitSingularUInt32Field(value: self.level, fieldNumber: 1)
    }
    if self.charging != false {
      try visitor.visitSingularBoolField(value: self.charging, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_BatteryStatus, rhs: Mentraos_Ble_BatteryStatus) -> Bool {
    if lhs.level != rhs.level {return false}
    if lhs.charging != rhs.charging {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_ChargingState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargingState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.state != .notCharging {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_ChargingState, rhs: Mentraos_Ble_ChargingState) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_ChargingState.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NOT_CHARGING"),
    1: .same(proto: "CHARGING"),
  ]
}

extension Mentraos_Ble_GlassesInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GlassesInfoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_GlassesInfoRequest, rhs: Mentraos_Ble_GlassesInfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_DeviceInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeviceInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fw_version"),
    2: .standard(proto: "hw_model"),
    3: .same(proto: "features"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fwVersion) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.hwModel) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._features) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.fwVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.fwVersion, fieldNumber: 1)
    }
    if !self.hwModel.isEmpty {
      try visitor.visitSingularStringField(value: self.hwModel, fieldNumber: 2)
    }
    try { if let v = self._features {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_DeviceInfo, rhs: Mentraos_Ble_DeviceInfo) -> Bool {
    if lhs.fwVersion != rhs.fwVersion {return false}
    if lhs.hwModel != rhs.hwModel {return false}
    if lhs._features != rhs._features {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_DeviceFeatures: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeviceFeatures"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "camera"),
    2: .same(proto: "display"),
    3: .standard(proto: "audio_tx"),
    4: .standard(proto: "audio_rx"),
    5: .same(proto: "imu"),
    6: .same(proto: "vad"),
    7: .standard(proto: "mic_switching"),
    8: .standard(proto: "image_chunk_buffer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.camera) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.display) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.audioTx) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.audioRx) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.imu) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.vad) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.micSwitching) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.imageChunkBuffer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.camera != false {
      try visitor.visitSingularBoolField(value: self.camera, fieldNumber: 1)
    }
    if self.display != false {
      try visitor.visitSingularBoolField(value: self.display, fieldNumber: 2)
    }
    if self.audioTx != false {
      try visitor.visitSingularBoolField(value: self.audioTx, fieldNumber: 3)
    }
    if self.audioRx != false {
      try visitor.visitSingularBoolField(value: self.audioRx, fieldNumber: 4)
    }
    if self.imu != false {
      try visitor.visitSingularBoolField(value: self.imu, fieldNumber: 5)
    }
    if self.vad != false {
      try visitor.visitSingularBoolField(value: self.vad, fieldNumber: 6)
    }
    if self.micSwitching != false {
      try visitor.visitSingularBoolField(value: self.micSwitching, fieldNumber: 7)
    }
    if self.imageChunkBuffer != 0 {
      try visitor.visitSingularUInt32Field(value: self.imageChunkBuffer, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_DeviceFeatures, rhs: Mentraos_Ble_DeviceFeatures) -> Bool {
    if lhs.camera != rhs.camera {return false}
    if lhs.display != rhs.display {return false}
    if lhs.audioTx != rhs.audioTx {return false}
    if lhs.audioRx != rhs.audioRx {return false}
    if lhs.imu != rhs.imu {return false}
    if lhs.vad != rhs.vad {return false}
    if lhs.micSwitching != rhs.micSwitching {return false}
    if lhs.imageChunkBuffer != rhs.imageChunkBuffer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_PairingModeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PairingModeRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_PairingModeRequest, rhs: Mentraos_Ble_PairingModeRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_HeadPositionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HeadPositionRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_HeadPositionRequest, rhs: Mentraos_Ble_HeadPositionRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_HeadPosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HeadPosition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "angle"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.angle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.angle != 0 {
      try visitor.visitSingularInt32Field(value: self.angle, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_HeadPosition, rhs: Mentraos_Ble_HeadPosition) -> Bool {
    if lhs.angle != rhs.angle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_HeadUpAngleConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HeadUpAngleConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "angle"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.angle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.angle != 0 {
      try visitor.visitSingularUInt32Field(value: self.angle, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_HeadUpAngleConfig, rhs: Mentraos_Ble_HeadUpAngleConfig) -> Bool {
    if lhs.angle != rhs.angle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_HeadUpAngleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HeadUpAngleResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_HeadUpAngleResponse, rhs: Mentraos_Ble_HeadUpAngleResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_PingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PingRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_PingRequest, rhs: Mentraos_Ble_PingRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_PongResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PongResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_PongResponse, rhs: Mentraos_Ble_PongResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_MicStateConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MicStateConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_MicStateConfig, rhs: Mentraos_Ble_MicStateConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_VadEnabledConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VadEnabledConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_VadEnabledConfig, rhs: Mentraos_Ble_VadEnabledConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_VadConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VadConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sensitivity"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.sensitivity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sensitivity != 0 {
      try visitor.visitSingularUInt32Field(value: self.sensitivity, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_VadConfig, rhs: Mentraos_Ble_VadConfig) -> Bool {
    if lhs.sensitivity != rhs.sensitivity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_VadEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VadEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.state != .inactive {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_VadEvent, rhs: Mentraos_Ble_VadEvent) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_VadEvent.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INACTIVE"),
    1: .same(proto: "ACTIVE"),
  ]
}

extension Mentraos_Ble_DisplayText: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisplayText"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "color"),
    3: .standard(proto: "font_code"),
    4: .same(proto: "x"),
    5: .same(proto: "y"),
    6: .same(proto: "size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.color) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.fontCode) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.x) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.y) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.size) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if self.color != 0 {
      try visitor.visitSingularUInt32Field(value: self.color, fieldNumber: 2)
    }
    if self.fontCode != 0 {
      try visitor.visitSingularUInt32Field(value: self.fontCode, fieldNumber: 3)
    }
    if self.x != 0 {
      try visitor.visitSingularUInt32Field(value: self.x, fieldNumber: 4)
    }
    if self.y != 0 {
      try visitor.visitSingularUInt32Field(value: self.y, fieldNumber: 5)
    }
    if self.size != 0 {
      try visitor.visitSingularUInt32Field(value: self.size, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_DisplayText, rhs: Mentraos_Ble_DisplayText) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.color != rhs.color {return false}
    if lhs.fontCode != rhs.fontCode {return false}
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.size != rhs.size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_DisplayImage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisplayImage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stream_id"),
    2: .same(proto: "x"),
    3: .same(proto: "y"),
    4: .same(proto: "width"),
    5: .same(proto: "height"),
    6: .same(proto: "encoding"),
    7: .standard(proto: "total_chunks"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.streamID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.x) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.y) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.width) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.height) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.encoding) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.totalChunks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.streamID.isEmpty {
      try visitor.visitSingularStringField(value: self.streamID, fieldNumber: 1)
    }
    if self.x != 0 {
      try visitor.visitSingularUInt32Field(value: self.x, fieldNumber: 2)
    }
    if self.y != 0 {
      try visitor.visitSingularUInt32Field(value: self.y, fieldNumber: 3)
    }
    if self.width != 0 {
      try visitor.visitSingularUInt32Field(value: self.width, fieldNumber: 4)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt32Field(value: self.height, fieldNumber: 5)
    }
    if !self.encoding.isEmpty {
      try visitor.visitSingularStringField(value: self.encoding, fieldNumber: 6)
    }
    if self.totalChunks != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalChunks, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_DisplayImage, rhs: Mentraos_Ble_DisplayImage) -> Bool {
    if lhs.streamID != rhs.streamID {return false}
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.encoding != rhs.encoding {return false}
    if lhs.totalChunks != rhs.totalChunks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_PreloadImage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PreloadImage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stream_id"),
    2: .standard(proto: "image_id"),
    3: .same(proto: "width"),
    4: .same(proto: "height"),
    5: .same(proto: "encoding"),
    6: .standard(proto: "total_chunks"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.streamID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.imageID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.width) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.height) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.encoding) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.totalChunks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.streamID.isEmpty {
      try visitor.visitSingularStringField(value: self.streamID, fieldNumber: 1)
    }
    if self.imageID != 0 {
      try visitor.visitSingularUInt32Field(value: self.imageID, fieldNumber: 2)
    }
    if self.width != 0 {
      try visitor.visitSingularUInt32Field(value: self.width, fieldNumber: 3)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt32Field(value: self.height, fieldNumber: 4)
    }
    if !self.encoding.isEmpty {
      try visitor.visitSingularStringField(value: self.encoding, fieldNumber: 5)
    }
    if self.totalChunks != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalChunks, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_PreloadImage, rhs: Mentraos_Ble_PreloadImage) -> Bool {
    if lhs.streamID != rhs.streamID {return false}
    if lhs.imageID != rhs.imageID {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.encoding != rhs.encoding {return false}
    if lhs.totalChunks != rhs.totalChunks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_DisplayCachedImage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisplayCachedImage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "image_id"),
    2: .same(proto: "x"),
    3: .same(proto: "y"),
    4: .same(proto: "width"),
    5: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.imageID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.x) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.y) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.width) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.height) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.imageID != 0 {
      try visitor.visitSingularUInt32Field(value: self.imageID, fieldNumber: 1)
    }
    if self.x != 0 {
      try visitor.visitSingularUInt32Field(value: self.x, fieldNumber: 2)
    }
    if self.y != 0 {
      try visitor.visitSingularUInt32Field(value: self.y, fieldNumber: 3)
    }
    if self.width != 0 {
      try visitor.visitSingularUInt32Field(value: self.width, fieldNumber: 4)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt32Field(value: self.height, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_DisplayCachedImage, rhs: Mentraos_Ble_DisplayCachedImage) -> Bool {
    if lhs.imageID != rhs.imageID {return false}
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_ClearCachedImage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClearCachedImage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "image_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.imageID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.imageID != 0 {
      try visitor.visitSingularUInt32Field(value: self.imageID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_ClearCachedImage, rhs: Mentraos_Ble_ClearCachedImage) -> Bool {
    if lhs.imageID != rhs.imageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_DisplayScrollingText: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisplayScrollingText"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "color"),
    3: .standard(proto: "font_code"),
    4: .same(proto: "x"),
    5: .same(proto: "y"),
    6: .same(proto: "width"),
    7: .same(proto: "height"),
    8: .same(proto: "align"),
    9: .standard(proto: "line_spacing"),
    10: .same(proto: "speed"),
    11: .same(proto: "size"),
    12: .same(proto: "loop"),
    13: .standard(proto: "pause_ms"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.color) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.fontCode) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.x) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.y) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.width) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.height) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.align) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.lineSpacing) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self.speed) }()
      case 11: try { try decoder.decodeSingularUInt32Field(value: &self.size) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.loop) }()
      case 13: try { try decoder.decodeSingularUInt32Field(value: &self.pauseMs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if self.color != 0 {
      try visitor.visitSingularUInt32Field(value: self.color, fieldNumber: 2)
    }
    if self.fontCode != 0 {
      try visitor.visitSingularUInt32Field(value: self.fontCode, fieldNumber: 3)
    }
    if self.x != 0 {
      try visitor.visitSingularUInt32Field(value: self.x, fieldNumber: 4)
    }
    if self.y != 0 {
      try visitor.visitSingularUInt32Field(value: self.y, fieldNumber: 5)
    }
    if self.width != 0 {
      try visitor.visitSingularUInt32Field(value: self.width, fieldNumber: 6)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt32Field(value: self.height, fieldNumber: 7)
    }
    if self.align != .left {
      try visitor.visitSingularEnumField(value: self.align, fieldNumber: 8)
    }
    if self.lineSpacing != 0 {
      try visitor.visitSingularUInt32Field(value: self.lineSpacing, fieldNumber: 9)
    }
    if self.speed != 0 {
      try visitor.visitSingularUInt32Field(value: self.speed, fieldNumber: 10)
    }
    if self.size != 0 {
      try visitor.visitSingularUInt32Field(value: self.size, fieldNumber: 11)
    }
    if self.loop != false {
      try visitor.visitSingularBoolField(value: self.loop, fieldNumber: 12)
    }
    if self.pauseMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.pauseMs, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_DisplayScrollingText, rhs: Mentraos_Ble_DisplayScrollingText) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.color != rhs.color {return false}
    if lhs.fontCode != rhs.fontCode {return false}
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.align != rhs.align {return false}
    if lhs.lineSpacing != rhs.lineSpacing {return false}
    if lhs.speed != rhs.speed {return false}
    if lhs.size != rhs.size {return false}
    if lhs.loop != rhs.loop {return false}
    if lhs.pauseMs != rhs.pauseMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_DisplayScrollingText.Alignment: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LEFT"),
    1: .same(proto: "CENTER"),
    2: .same(proto: "RIGHT"),
  ]
}

extension Mentraos_Ble_DisplayPowerConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisplayPowerConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "on"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.on) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.on != false {
      try visitor.visitSingularBoolField(value: self.on, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_DisplayPowerConfig, rhs: Mentraos_Ble_DisplayPowerConfig) -> Bool {
    if lhs.on != rhs.on {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_BrightnessConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BrightnessConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt32Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_BrightnessConfig, rhs: Mentraos_Ble_BrightnessConfig) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_AutoBrightnessConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AutoBrightnessConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_AutoBrightnessConfig, rhs: Mentraos_Ble_AutoBrightnessConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_AutoBrightnessMultiplier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AutoBrightnessMultiplier"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "multiplier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.multiplier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.multiplier.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.multiplier, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_AutoBrightnessMultiplier, rhs: Mentraos_Ble_AutoBrightnessMultiplier) -> Bool {
    if lhs.multiplier != rhs.multiplier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_DrawLine: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DrawLine"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "color"),
    2: .same(proto: "stroke"),
    3: .same(proto: "x1"),
    4: .same(proto: "y1"),
    5: .same(proto: "x2"),
    6: .same(proto: "y2"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.color) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.stroke) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.x1) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.y1) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.x2) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.y2) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.color != 0 {
      try visitor.visitSingularUInt32Field(value: self.color, fieldNumber: 1)
    }
    if self.stroke != 0 {
      try visitor.visitSingularUInt32Field(value: self.stroke, fieldNumber: 2)
    }
    if self.x1 != 0 {
      try visitor.visitSingularUInt32Field(value: self.x1, fieldNumber: 3)
    }
    if self.y1 != 0 {
      try visitor.visitSingularUInt32Field(value: self.y1, fieldNumber: 4)
    }
    if self.x2 != 0 {
      try visitor.visitSingularUInt32Field(value: self.x2, fieldNumber: 5)
    }
    if self.y2 != 0 {
      try visitor.visitSingularUInt32Field(value: self.y2, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_DrawLine, rhs: Mentraos_Ble_DrawLine) -> Bool {
    if lhs.color != rhs.color {return false}
    if lhs.stroke != rhs.stroke {return false}
    if lhs.x1 != rhs.x1 {return false}
    if lhs.y1 != rhs.y1 {return false}
    if lhs.x2 != rhs.x2 {return false}
    if lhs.y2 != rhs.y2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_DrawRect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DrawRect"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "color"),
    2: .same(proto: "stroke"),
    3: .same(proto: "x"),
    4: .same(proto: "y"),
    5: .same(proto: "width"),
    6: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.color) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.stroke) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.x) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.y) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.width) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.height) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.color != 0 {
      try visitor.visitSingularUInt32Field(value: self.color, fieldNumber: 1)
    }
    if self.stroke != 0 {
      try visitor.visitSingularUInt32Field(value: self.stroke, fieldNumber: 2)
    }
    if self.x != 0 {
      try visitor.visitSingularUInt32Field(value: self.x, fieldNumber: 3)
    }
    if self.y != 0 {
      try visitor.visitSingularUInt32Field(value: self.y, fieldNumber: 4)
    }
    if self.width != 0 {
      try visitor.visitSingularUInt32Field(value: self.width, fieldNumber: 5)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt32Field(value: self.height, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_DrawRect, rhs: Mentraos_Ble_DrawRect) -> Bool {
    if lhs.color != rhs.color {return false}
    if lhs.stroke != rhs.stroke {return false}
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_DrawCircle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DrawCircle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "color"),
    2: .same(proto: "stroke"),
    3: .same(proto: "x"),
    4: .same(proto: "y"),
    5: .same(proto: "radius"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.color) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.stroke) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.x) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.y) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.radius) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.color != 0 {
      try visitor.visitSingularUInt32Field(value: self.color, fieldNumber: 1)
    }
    if self.stroke != 0 {
      try visitor.visitSingularUInt32Field(value: self.stroke, fieldNumber: 2)
    }
    if self.x != 0 {
      try visitor.visitSingularUInt32Field(value: self.x, fieldNumber: 3)
    }
    if self.y != 0 {
      try visitor.visitSingularUInt32Field(value: self.y, fieldNumber: 4)
    }
    if self.radius != 0 {
      try visitor.visitSingularUInt32Field(value: self.radius, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_DrawCircle, rhs: Mentraos_Ble_DrawCircle) -> Bool {
    if lhs.color != rhs.color {return false}
    if lhs.stroke != rhs.stroke {return false}
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.radius != rhs.radius {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_CommitDisplay: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommitDisplay"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_CommitDisplay, rhs: Mentraos_Ble_CommitDisplay) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_DisplayDistanceConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisplayDistanceConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "distance_cm"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.distanceCm) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.distanceCm != 0 {
      try visitor.visitSingularUInt32Field(value: self.distanceCm, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_DisplayDistanceConfig, rhs: Mentraos_Ble_DisplayDistanceConfig) -> Bool {
    if lhs.distanceCm != rhs.distanceCm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_DisplayHeightConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisplayHeightConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "depth"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.height) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.depth) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.height != 0 {
      try visitor.visitSingularUInt32Field(value: self.height, fieldNumber: 1)
    }
    if self.depth != 0 {
      try visitor.visitSingularUInt32Field(value: self.depth, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_DisplayHeightConfig, rhs: Mentraos_Ble_DisplayHeightConfig) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.depth != rhs.depth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_ImageTransferComplete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImageTransferComplete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stream_id"),
    2: .same(proto: "status"),
    3: .standard(proto: "missing_chunks"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.streamID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 3: try { try decoder.decodeRepeatedUInt32Field(value: &self.missingChunks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.streamID.isEmpty {
      try visitor.visitSingularStringField(value: self.streamID, fieldNumber: 1)
    }
    if self.status != .ok {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if !self.missingChunks.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.missingChunks, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_ImageTransferComplete, rhs: Mentraos_Ble_ImageTransferComplete) -> Bool {
    if lhs.streamID != rhs.streamID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.missingChunks != rhs.missingChunks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_ImageTransferComplete.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "INCOMPLETE"),
  ]
}

extension Mentraos_Ble_ImuEnabledConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImuEnabledConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_ImuEnabledConfig, rhs: Mentraos_Ble_ImuEnabledConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_ImuSingleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImuSingleRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_ImuSingleRequest, rhs: Mentraos_Ble_ImuSingleRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_ImuStreamConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImuStreamConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_ImuStreamConfig, rhs: Mentraos_Ble_ImuStreamConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_ImuData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImuData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accel"),
    2: .same(proto: "gyro"),
    3: .same(proto: "mag"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._accel) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._gyro) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._mag) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._accel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._gyro {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._mag {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_ImuData, rhs: Mentraos_Ble_ImuData) -> Bool {
    if lhs._accel != rhs._accel {return false}
    if lhs._gyro != rhs._gyro {return false}
    if lhs._mag != rhs._mag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_Vector3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Vector3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "z"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.y) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.z) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.x, fieldNumber: 1)
    }
    if self.y.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.y, fieldNumber: 2)
    }
    if self.z.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.z, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_Vector3, rhs: Mentraos_Ble_Vector3) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_ButtonEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ButtonEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "button"),
    2: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.button) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.button != .center {
      try visitor.visitSingularEnumField(value: self.button, fieldNumber: 1)
    }
    if self.state != .up {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_ButtonEvent, rhs: Mentraos_Ble_ButtonEvent) -> Bool {
    if lhs.button != rhs.button {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_ButtonEvent.Button: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CENTER"),
    1: .same(proto: "LEFT"),
    2: .same(proto: "RIGHT"),
  ]
}

extension Mentraos_Ble_ButtonEvent.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UP"),
    1: .same(proto: "DOWN"),
  ]
}

extension Mentraos_Ble_HeadGesture: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HeadGesture"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gesture"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.gesture) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.gesture != .nod {
      try visitor.visitSingularEnumField(value: self.gesture, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_HeadGesture, rhs: Mentraos_Ble_HeadGesture) -> Bool {
    if lhs.gesture != rhs.gesture {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_HeadGesture.Gesture: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NOD"),
    1: .same(proto: "SHAKE"),
    2: .same(proto: "HEAD_UP"),
  ]
}

extension Mentraos_Ble_HeadGestureConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HeadGestureConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gesture"),
    2: .same(proto: "enabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.gesture) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.gesture != .nod {
      try visitor.visitSingularEnumField(value: self.gesture, fieldNumber: 1)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_HeadGestureConfig, rhs: Mentraos_Ble_HeadGestureConfig) -> Bool {
    if lhs.gesture != rhs.gesture {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_RestartRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RestartRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_RestartRequest, rhs: Mentraos_Ble_RestartRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_FactoryResetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FactoryResetRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_FactoryResetRequest, rhs: Mentraos_Ble_FactoryResetRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
