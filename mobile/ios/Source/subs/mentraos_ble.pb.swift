// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: mentraos_ble.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// All messages from phone to glasses
struct Mentraos_Ble_PhoneToGlasses: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var msgID: String = String()

  var payload: Mentraos_Ble_PhoneToGlasses.OneOf_Payload? = nil

  /// Connection Management
  var disconnect: Mentraos_Ble_DisconnectRequest {
    get {
      if case .disconnect(let v)? = payload {return v}
      return Mentraos_Ble_DisconnectRequest()
    }
    set {payload = .disconnect(newValue)}
  }

  var batteryState: Mentraos_Ble_BatteryStateRequest {
    get {
      if case .batteryState(let v)? = payload {return v}
      return Mentraos_Ble_BatteryStateRequest()
    }
    set {payload = .batteryState(newValue)}
  }

  var glassesInfo: Mentraos_Ble_GlassesInfoRequest {
    get {
      if case .glassesInfo(let v)? = payload {return v}
      return Mentraos_Ble_GlassesInfoRequest()
    }
    set {payload = .glassesInfo(newValue)}
  }

  var pairingMode: Mentraos_Ble_PairingModeRequest {
    get {
      if case .pairingMode(let v)? = payload {return v}
      return Mentraos_Ble_PairingModeRequest()
    }
    set {payload = .pairingMode(newValue)}
  }

  var headPosition: Mentraos_Ble_HeadPositionRequest {
    get {
      if case .headPosition(let v)? = payload {return v}
      return Mentraos_Ble_HeadPositionRequest()
    }
    set {payload = .headPosition(newValue)}
  }

  var headUpAngle: Mentraos_Ble_HeadUpAngleConfig {
    get {
      if case .headUpAngle(let v)? = payload {return v}
      return Mentraos_Ble_HeadUpAngleConfig()
    }
    set {payload = .headUpAngle(newValue)}
  }

  var pong: Mentraos_Ble_PongResponse {
    get {
      if case .pong(let v)? = payload {return v}
      return Mentraos_Ble_PongResponse()
    }
    set {payload = .pong(newValue)}
  }

  /// Audio System
  var micState: Mentraos_Ble_MicStateConfig {
    get {
      if case .micState(let v)? = payload {return v}
      return Mentraos_Ble_MicStateConfig()
    }
    set {payload = .micState(newValue)}
  }

  var setVadEnabled: Mentraos_Ble_VadEnabledRequest {
    get {
      if case .setVadEnabled(let v)? = payload {return v}
      return Mentraos_Ble_VadEnabledRequest()
    }
    set {payload = .setVadEnabled(newValue)}
  }

  var setVadConfig: Mentraos_Ble_VadConfigRequest {
    get {
      if case .setVadConfig(let v)? = payload {return v}
      return Mentraos_Ble_VadConfigRequest()
    }
    set {payload = .setVadConfig(newValue)}
  }

  var requestVadStatus: Mentraos_Ble_VadStatusRequest {
    get {
      if case .requestVadStatus(let v)? = payload {return v}
      return Mentraos_Ble_VadStatusRequest()
    }
    set {payload = .requestVadStatus(newValue)}
  }

  /// Display System - These queue until commit
  var displayText: Mentraos_Ble_DisplayText {
    get {
      if case .displayText(let v)? = payload {return v}
      return Mentraos_Ble_DisplayText()
    }
    set {payload = .displayText(newValue)}
  }

  var displayImage: Mentraos_Ble_DisplayImage {
    get {
      if case .displayImage(let v)? = payload {return v}
      return Mentraos_Ble_DisplayImage()
    }
    set {payload = .displayImage(newValue)}
  }

  var cacheImage: Mentraos_Ble_CacheImage {
    get {
      if case .cacheImage(let v)? = payload {return v}
      return Mentraos_Ble_CacheImage()
    }
    set {payload = .cacheImage(newValue)}
  }

  var displayCachedImage: Mentraos_Ble_DisplayCachedImage {
    get {
      if case .displayCachedImage(let v)? = payload {return v}
      return Mentraos_Ble_DisplayCachedImage()
    }
    set {payload = .displayCachedImage(newValue)}
  }

  var clearCachedImage_p: Mentraos_Ble_ClearCachedImage {
    get {
      if case .clearCachedImage_p(let v)? = payload {return v}
      return Mentraos_Ble_ClearCachedImage()
    }
    set {payload = .clearCachedImage_p(newValue)}
  }

  var displayScrollingText: Mentraos_Ble_DisplayScrollingText {
    get {
      if case .displayScrollingText(let v)? = payload {return v}
      return Mentraos_Ble_DisplayScrollingText()
    }
    set {payload = .displayScrollingText(newValue)}
  }

  var drawLine: Mentraos_Ble_DrawLine {
    get {
      if case .drawLine(let v)? = payload {return v}
      return Mentraos_Ble_DrawLine()
    }
    set {payload = .drawLine(newValue)}
  }

  var drawRect: Mentraos_Ble_DrawRect {
    get {
      if case .drawRect(let v)? = payload {return v}
      return Mentraos_Ble_DrawRect()
    }
    set {payload = .drawRect(newValue)}
  }

  var drawCircle: Mentraos_Ble_DrawCircle {
    get {
      if case .drawCircle(let v)? = payload {return v}
      return Mentraos_Ble_DrawCircle()
    }
    set {payload = .drawCircle(newValue)}
  }

  /// Send multiple commands at once
  var displayBatch: Mentraos_Ble_DisplayBatch {
    get {
      if case .displayBatch(let v)? = payload {return v}
      return Mentraos_Ble_DisplayBatch()
    }
    set {payload = .displayBatch(newValue)}
  }

  /// Renders all queued commands
  var commit: Mentraos_Ble_CommitDisplay {
    get {
      if case .commit(let v)? = payload {return v}
      return Mentraos_Ble_CommitDisplay()
    }
    set {payload = .commit(newValue)}
  }

  /// Display Control - These execute immediately
  var displayPower: Mentraos_Ble_DisplayPowerConfig {
    get {
      if case .displayPower(let v)? = payload {return v}
      return Mentraos_Ble_DisplayPowerConfig()
    }
    set {payload = .displayPower(newValue)}
  }

  var brightness: Mentraos_Ble_BrightnessConfig {
    get {
      if case .brightness(let v)? = payload {return v}
      return Mentraos_Ble_BrightnessConfig()
    }
    set {payload = .brightness(newValue)}
  }

  var autoBrightness: Mentraos_Ble_AutoBrightnessConfig {
    get {
      if case .autoBrightness(let v)? = payload {return v}
      return Mentraos_Ble_AutoBrightnessConfig()
    }
    set {payload = .autoBrightness(newValue)}
  }

  var autoBrightnessMult: Mentraos_Ble_AutoBrightnessMultiplier {
    get {
      if case .autoBrightnessMult(let v)? = payload {return v}
      return Mentraos_Ble_AutoBrightnessMultiplier()
    }
    set {payload = .autoBrightnessMult(newValue)}
  }

  var displayDistance: Mentraos_Ble_DisplayDistanceConfig {
    get {
      if case .displayDistance(let v)? = payload {return v}
      return Mentraos_Ble_DisplayDistanceConfig()
    }
    set {payload = .displayDistance(newValue)}
  }

  var displayHeight: Mentraos_Ble_DisplayHeightConfig {
    get {
      if case .displayHeight(let v)? = payload {return v}
      return Mentraos_Ble_DisplayHeightConfig()
    }
    set {payload = .displayHeight(newValue)}
  }

  var clearDisplay_p: Mentraos_Ble_ClearDisplay {
    get {
      if case .clearDisplay_p(let v)? = payload {return v}
      return Mentraos_Ble_ClearDisplay()
    }
    set {payload = .clearDisplay_p(newValue)}
  }

  /// Get queue info
  var queueStatusRequest: Mentraos_Ble_DisplayQueueStatus {
    get {
      if case .queueStatusRequest(let v)? = payload {return v}
      return Mentraos_Ble_DisplayQueueStatus()
    }
    set {payload = .queueStatusRequest(newValue)}
  }

  /// Dashboard/Cacheboard System
  var cacheDashboard: Mentraos_Ble_CacheDashboard {
    get {
      if case .cacheDashboard(let v)? = payload {return v}
      return Mentraos_Ble_CacheDashboard()
    }
    set {payload = .cacheDashboard(newValue)}
  }

  var clearDashboard_p: Mentraos_Ble_ClearDashboard {
    get {
      if case .clearDashboard_p(let v)? = payload {return v}
      return Mentraos_Ble_ClearDashboard()
    }
    set {payload = .clearDashboard_p(newValue)}
  }

  var dashboardTrigger: Mentraos_Ble_ConfigureDashboardTrigger {
    get {
      if case .dashboardTrigger(let v)? = payload {return v}
      return Mentraos_Ble_ConfigureDashboardTrigger()
    }
    set {payload = .dashboardTrigger(newValue)}
  }

  /// User Input
  var imuEnabled: Mentraos_Ble_ImuEnabledConfig {
    get {
      if case .imuEnabled(let v)? = payload {return v}
      return Mentraos_Ble_ImuEnabledConfig()
    }
    set {payload = .imuEnabled(newValue)}
  }

  var imuSingle: Mentraos_Ble_ImuSingleRequest {
    get {
      if case .imuSingle(let v)? = payload {return v}
      return Mentraos_Ble_ImuSingleRequest()
    }
    set {payload = .imuSingle(newValue)}
  }

  var imuStream: Mentraos_Ble_ImuStreamConfig {
    get {
      if case .imuStream(let v)? = payload {return v}
      return Mentraos_Ble_ImuStreamConfig()
    }
    set {payload = .imuStream(newValue)}
  }

  var headGesture: Mentraos_Ble_HeadGestureConfig {
    get {
      if case .headGesture(let v)? = payload {return v}
      return Mentraos_Ble_HeadGestureConfig()
    }
    set {payload = .headGesture(newValue)}
  }

  /// System Control
  var restart: Mentraos_Ble_RestartRequest {
    get {
      if case .restart(let v)? = payload {return v}
      return Mentraos_Ble_RestartRequest()
    }
    set {payload = .restart(newValue)}
  }

  var factoryReset: Mentraos_Ble_FactoryResetRequest {
    get {
      if case .factoryReset(let v)? = payload {return v}
      return Mentraos_Ble_FactoryResetRequest()
    }
    set {payload = .factoryReset(newValue)}
  }

  /// Runtime protocol version query
  var versionRequest: Mentraos_Ble_VersionRequest {
    get {
      if case .versionRequest(let v)? = payload {return v}
      return Mentraos_Ble_VersionRequest()
    }
    set {payload = .versionRequest(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Payload: Equatable, Sendable {
    /// Connection Management
    case disconnect(Mentraos_Ble_DisconnectRequest)
    case batteryState(Mentraos_Ble_BatteryStateRequest)
    case glassesInfo(Mentraos_Ble_GlassesInfoRequest)
    case pairingMode(Mentraos_Ble_PairingModeRequest)
    case headPosition(Mentraos_Ble_HeadPositionRequest)
    case headUpAngle(Mentraos_Ble_HeadUpAngleConfig)
    case pong(Mentraos_Ble_PongResponse)
    /// Audio System
    case micState(Mentraos_Ble_MicStateConfig)
    case setVadEnabled(Mentraos_Ble_VadEnabledRequest)
    case setVadConfig(Mentraos_Ble_VadConfigRequest)
    case requestVadStatus(Mentraos_Ble_VadStatusRequest)
    /// Display System - These queue until commit
    case displayText(Mentraos_Ble_DisplayText)
    case displayImage(Mentraos_Ble_DisplayImage)
    case cacheImage(Mentraos_Ble_CacheImage)
    case displayCachedImage(Mentraos_Ble_DisplayCachedImage)
    case clearCachedImage_p(Mentraos_Ble_ClearCachedImage)
    case displayScrollingText(Mentraos_Ble_DisplayScrollingText)
    case drawLine(Mentraos_Ble_DrawLine)
    case drawRect(Mentraos_Ble_DrawRect)
    case drawCircle(Mentraos_Ble_DrawCircle)
    /// Send multiple commands at once
    case displayBatch(Mentraos_Ble_DisplayBatch)
    /// Renders all queued commands
    case commit(Mentraos_Ble_CommitDisplay)
    /// Display Control - These execute immediately
    case displayPower(Mentraos_Ble_DisplayPowerConfig)
    case brightness(Mentraos_Ble_BrightnessConfig)
    case autoBrightness(Mentraos_Ble_AutoBrightnessConfig)
    case autoBrightnessMult(Mentraos_Ble_AutoBrightnessMultiplier)
    case displayDistance(Mentraos_Ble_DisplayDistanceConfig)
    case displayHeight(Mentraos_Ble_DisplayHeightConfig)
    case clearDisplay_p(Mentraos_Ble_ClearDisplay)
    /// Get queue info
    case queueStatusRequest(Mentraos_Ble_DisplayQueueStatus)
    /// Dashboard/Cacheboard System
    case cacheDashboard(Mentraos_Ble_CacheDashboard)
    case clearDashboard_p(Mentraos_Ble_ClearDashboard)
    case dashboardTrigger(Mentraos_Ble_ConfigureDashboardTrigger)
    /// User Input
    case imuEnabled(Mentraos_Ble_ImuEnabledConfig)
    case imuSingle(Mentraos_Ble_ImuSingleRequest)
    case imuStream(Mentraos_Ble_ImuStreamConfig)
    case headGesture(Mentraos_Ble_HeadGestureConfig)
    /// System Control
    case restart(Mentraos_Ble_RestartRequest)
    case factoryReset(Mentraos_Ble_FactoryResetRequest)
    /// Runtime protocol version query
    case versionRequest(Mentraos_Ble_VersionRequest)

  }

  init() {}
}

/// All messages from glasses to phone
struct Mentraos_Ble_GlassesToPhone: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var payload: Mentraos_Ble_GlassesToPhone.OneOf_Payload? = nil

  /// Connection Management
  var batteryStatus: Mentraos_Ble_BatteryStatus {
    get {
      if case .batteryStatus(let v)? = payload {return v}
      return Mentraos_Ble_BatteryStatus()
    }
    set {payload = .batteryStatus(newValue)}
  }

  var chargingState: Mentraos_Ble_ChargingState {
    get {
      if case .chargingState(let v)? = payload {return v}
      return Mentraos_Ble_ChargingState()
    }
    set {payload = .chargingState(newValue)}
  }

  var deviceInfo: Mentraos_Ble_DeviceInfo {
    get {
      if case .deviceInfo(let v)? = payload {return v}
      return Mentraos_Ble_DeviceInfo()
    }
    set {payload = .deviceInfo(newValue)}
  }

  var headPosition: Mentraos_Ble_HeadPosition {
    get {
      if case .headPosition(let v)? = payload {return v}
      return Mentraos_Ble_HeadPosition()
    }
    set {payload = .headPosition(newValue)}
  }

  var headUpAngleSet: Mentraos_Ble_HeadUpAngleResponse {
    get {
      if case .headUpAngleSet(let v)? = payload {return v}
      return Mentraos_Ble_HeadUpAngleResponse()
    }
    set {payload = .headUpAngleSet(newValue)}
  }

  var ping: Mentraos_Ble_PingRequest {
    get {
      if case .ping(let v)? = payload {return v}
      return Mentraos_Ble_PingRequest()
    }
    set {payload = .ping(newValue)}
  }

  /// Audio System
  var vadEvent: Mentraos_Ble_VadEvent {
    get {
      if case .vadEvent(let v)? = payload {return v}
      return Mentraos_Ble_VadEvent()
    }
    set {payload = .vadEvent(newValue)}
  }

  /// response to set_vad_enabled
  var vadEnabledSet: Mentraos_Ble_VadEnabledResponse {
    get {
      if case .vadEnabledSet(let v)? = payload {return v}
      return Mentraos_Ble_VadEnabledResponse()
    }
    set {payload = .vadEnabledSet(newValue)}
  }

  /// response to set_vad_config
  var vadConfigured: Mentraos_Ble_VadConfigResponse {
    get {
      if case .vadConfigured(let v)? = payload {return v}
      return Mentraos_Ble_VadConfigResponse()
    }
    set {payload = .vadConfigured(newValue)}
  }

  /// response to request_vad_status
  var vadStatus: Mentraos_Ble_VadStatus {
    get {
      if case .vadStatus(let v)? = payload {return v}
      return Mentraos_Ble_VadStatus()
    }
    set {payload = .vadStatus(newValue)}
  }

  /// Display System
  var imageTransferComplete: Mentraos_Ble_ImageTransferComplete {
    get {
      if case .imageTransferComplete(let v)? = payload {return v}
      return Mentraos_Ble_ImageTransferComplete()
    }
    set {payload = .imageTransferComplete(newValue)}
  }

  var displayQueueInfo: Mentraos_Ble_DisplayQueueInfo {
    get {
      if case .displayQueueInfo(let v)? = payload {return v}
      return Mentraos_Ble_DisplayQueueInfo()
    }
    set {payload = .displayQueueInfo(newValue)}
  }

  /// User Input
  var imuData: Mentraos_Ble_ImuData {
    get {
      if case .imuData(let v)? = payload {return v}
      return Mentraos_Ble_ImuData()
    }
    set {payload = .imuData(newValue)}
  }

  var buttonEvent: Mentraos_Ble_ButtonEvent {
    get {
      if case .buttonEvent(let v)? = payload {return v}
      return Mentraos_Ble_ButtonEvent()
    }
    set {payload = .buttonEvent(newValue)}
  }

  var headGesture: Mentraos_Ble_HeadGesture {
    get {
      if case .headGesture(let v)? = payload {return v}
      return Mentraos_Ble_HeadGesture()
    }
    set {payload = .headGesture(newValue)}
  }

  /// Dashboard System
  var dashboardShown: Mentraos_Ble_DashboardShown {
    get {
      if case .dashboardShown(let v)? = payload {return v}
      return Mentraos_Ble_DashboardShown()
    }
    set {payload = .dashboardShown(newValue)}
  }

  /// Runtime protocol version response
  var versionResponse: Mentraos_Ble_VersionResponse {
    get {
      if case .versionResponse(let v)? = payload {return v}
      return Mentraos_Ble_VersionResponse()
    }
    set {payload = .versionResponse(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Payload: Equatable, Sendable {
    /// Connection Management
    case batteryStatus(Mentraos_Ble_BatteryStatus)
    case chargingState(Mentraos_Ble_ChargingState)
    case deviceInfo(Mentraos_Ble_DeviceInfo)
    case headPosition(Mentraos_Ble_HeadPosition)
    case headUpAngleSet(Mentraos_Ble_HeadUpAngleResponse)
    case ping(Mentraos_Ble_PingRequest)
    /// Audio System
    case vadEvent(Mentraos_Ble_VadEvent)
    /// response to set_vad_enabled
    case vadEnabledSet(Mentraos_Ble_VadEnabledResponse)
    /// response to set_vad_config
    case vadConfigured(Mentraos_Ble_VadConfigResponse)
    /// response to request_vad_status
    case vadStatus(Mentraos_Ble_VadStatus)
    /// Display System
    case imageTransferComplete(Mentraos_Ble_ImageTransferComplete)
    case displayQueueInfo(Mentraos_Ble_DisplayQueueInfo)
    /// User Input
    case imuData(Mentraos_Ble_ImuData)
    case buttonEvent(Mentraos_Ble_ButtonEvent)
    case headGesture(Mentraos_Ble_HeadGesture)
    /// Dashboard System
    case dashboardShown(Mentraos_Ble_DashboardShown)
    /// Runtime protocol version response
    case versionResponse(Mentraos_Ble_VersionResponse)

  }

  init() {}
}

struct Mentraos_Ble_DisconnectRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_BatteryStateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_BatteryStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 0-100 percentage
  var level: UInt32 = 0

  var charging: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_ChargingState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var state: Mentraos_Ble_ChargingState.State = .notCharging

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case notCharging // = 0
    case charging // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .notCharging
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .notCharging
      case 1: self = .charging
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .notCharging: return 0
      case .charging: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Mentraos_Ble_ChargingState.State] = [
      .notCharging,
      .charging,
    ]

  }

  init() {}
}

struct Mentraos_Ble_GlassesInfoRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_DeviceInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fwVersion: String = String()

  var hwModel: String = String()

  var features: Mentraos_Ble_DeviceFeatures {
    get {return _features ?? Mentraos_Ble_DeviceFeatures()}
    set {_features = newValue}
  }
  /// Returns true if `features` has been explicitly set.
  var hasFeatures: Bool {return self._features != nil}
  /// Clears the value of `features`. Subsequent reads from it will return its default value.
  mutating func clearFeatures() {self._features = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _features: Mentraos_Ble_DeviceFeatures? = nil
}

struct Mentraos_Ble_DeviceFeatures: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var camera: Bool = false

  var display: Bool = false

  var audioTx: Bool = false

  var audioRx: Bool = false

  var imu: Bool = false

  var vad: Bool = false

  var micSwitching: Bool = false

  /// Max chunks that can be buffered
  var imageChunkBuffer: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_PairingModeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_HeadPositionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_HeadPosition: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// degrees
  var angle: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_HeadUpAngleConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// degrees
  var angle: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_HeadUpAngleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_PingRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var msgID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_PongResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_MicStateConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Events: emitted when voice activity starts/stops
struct Mentraos_Ble_VadEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var state: Mentraos_Ble_VadEvent.State = .inactive

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case inactive // = 0
    case active // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .inactive
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .inactive
      case 1: self = .active
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .inactive: return 0
      case .active: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Mentraos_Ble_VadEvent.State] = [
      .inactive,
      .active,
    ]

  }

  init() {}
}

/// Enable/disable VAD (request)
struct Mentraos_Ble_VadEnabledRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var msgID: String = String()

  var enabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response to enable/disable VAD
struct Mentraos_Ble_VadEnabledResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// echoes request
  var msgID: String = String()

  var success: Bool = false

  /// optional diagnostics
  var error: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Configure VAD sensitivity (request)
struct Mentraos_Ble_VadConfigRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var msgID: String = String()

  /// 0-100
  var sensitivity: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response to VAD config
struct Mentraos_Ble_VadConfigResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// echoes request
  var msgID: String = String()

  var success: Bool = false

  /// optional diagnostics
  var error: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Query current VAD state (request)
struct Mentraos_Ble_VadStatusRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var msgID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Current VAD state (response)
struct Mentraos_Ble_VadStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// echoes request
  var msgID: String = String()

  var enabled: Bool = false

  /// 0-100
  var sensitivity: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_DisplayText: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var text: String = String()

  /// RGB565 format (e.g., 0xF800 for red)
  var color: UInt32 = 0

  var x: UInt32 = 0

  var y: UInt32 = 0

  /// Font size as integer
  var size: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Initiates bitmap transfer - actual data comes via binary protocol
struct Mentraos_Ble_DisplayImage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 2-byte hex string like "002A"
  var streamID: String = String()

  var x: UInt32 = 0

  var y: UInt32 = 0

  var width: UInt32 = 0

  var height: UInt32 = 0

  /// "rle", "webp", etc.
  var encoding: String = String()

  var totalChunks: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_CacheImage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var streamID: String = String()

  /// ID for later reference
  var imageID: UInt32 = 0

  var width: UInt32 = 0

  var height: UInt32 = 0

  var encoding: String = String()

  var totalChunks: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_DisplayCachedImage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var imageID: UInt32 = 0

  var x: UInt32 = 0

  var y: UInt32 = 0

  var width: UInt32 = 0

  var height: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_ClearCachedImage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var imageID: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_DisplayScrollingText: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var text: String = String()

  var color: UInt32 = 0

  /// Text box X position
  var x: UInt32 = 0

  /// Text box Y position
  var y: UInt32 = 0

  /// Text box width (for LVGL wrapping)
  var width: UInt32 = 0

  /// Text box height (truncate with ellipses if exceeded)
  var height: UInt32 = 0

  var align: Mentraos_Ble_DisplayScrollingText.Alignment = .left

  /// pixels between lines
  var lineSpacing: UInt32 = 0

  /// pixels/sec scrolling up
  var speed: UInt32 = 0

  /// Font size as integer
  var size: UInt32 = 0

  /// wrap to top when finished
  var loop: Bool = false

  /// delay before restart (if looping)
  var pauseMs: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Alignment: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case left // = 0
    case center // = 1
    case right // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .left
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .left
      case 1: self = .center
      case 2: self = .right
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .left: return 0
      case .center: return 1
      case .right: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Mentraos_Ble_DisplayScrollingText.Alignment] = [
      .left,
      .center,
      .right,
    ]

  }

  init() {}
}

struct Mentraos_Ble_DisplayPowerConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// true = turn on, false = turn off
  var on: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_BrightnessConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 0-100
  var value: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_AutoBrightnessConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_AutoBrightnessMultiplier: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// e.g., 0.8 = 80%
  var multiplier: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_DrawLine: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var color: UInt32 = 0

  var stroke: UInt32 = 0

  var x1: UInt32 = 0

  var y1: UInt32 = 0

  var x2: UInt32 = 0

  var y2: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_DrawRect: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var color: UInt32 = 0

  var stroke: UInt32 = 0

  var x: UInt32 = 0

  var y: UInt32 = 0

  var width: UInt32 = 0

  var height: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_DrawCircle: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var color: UInt32 = 0

  var stroke: UInt32 = 0

  var x: UInt32 = 0

  var y: UInt32 = 0

  var radius: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Send multiple display commands in a single message (more efficient)
struct Mentraos_Ble_DisplayBatch: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var commands: [Mentraos_Ble_DisplayBatch.DisplayCommand] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct DisplayCommand: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var command: Mentraos_Ble_DisplayBatch.DisplayCommand.OneOf_Command? = nil

    var text: Mentraos_Ble_DisplayText {
      get {
        if case .text(let v)? = command {return v}
        return Mentraos_Ble_DisplayText()
      }
      set {command = .text(newValue)}
    }

    var cachedImage: Mentraos_Ble_DisplayCachedImage {
      get {
        if case .cachedImage(let v)? = command {return v}
        return Mentraos_Ble_DisplayCachedImage()
      }
      set {command = .cachedImage(newValue)}
    }

    var line: Mentraos_Ble_DrawLine {
      get {
        if case .line(let v)? = command {return v}
        return Mentraos_Ble_DrawLine()
      }
      set {command = .line(newValue)}
    }

    var rect: Mentraos_Ble_DrawRect {
      get {
        if case .rect(let v)? = command {return v}
        return Mentraos_Ble_DrawRect()
      }
      set {command = .rect(newValue)}
    }

    var circle: Mentraos_Ble_DrawCircle {
      get {
        if case .circle(let v)? = command {return v}
        return Mentraos_Ble_DrawCircle()
      }
      set {command = .circle(newValue)}
    }

    var scrollingText: Mentraos_Ble_DisplayScrollingText {
      get {
        if case .scrollingText(let v)? = command {return v}
        return Mentraos_Ble_DisplayScrollingText()
      }
      set {command = .scrollingText(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Command: Equatable, Sendable {
      case text(Mentraos_Ble_DisplayText)
      case cachedImage(Mentraos_Ble_DisplayCachedImage)
      case line(Mentraos_Ble_DrawLine)
      case rect(Mentraos_Ble_DrawRect)
      case circle(Mentraos_Ble_DrawCircle)
      case scrollingText(Mentraos_Ble_DisplayScrollingText)

    }

    init() {}
  }

  init() {}
}

/// Commits all queued display commands to screen atomically
/// All display commands since last commit are rendered together
struct Mentraos_Ble_CommitDisplay: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional: clear screen before applying commands
  var clearBefore_p: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Clears display immediately (NOT queued, happens right away)
struct Mentraos_Ble_ClearDisplay: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request status of display queue
struct Mentraos_Ble_DisplayQueueStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response with queue information
struct Mentraos_Ble_DisplayQueueInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Number of commands waiting for commit
  var queuedCommands: UInt32 = 0

  /// Memory used by queue
  var queueBytes: UInt32 = 0

  /// Maximum queue size in bytes
  var maxQueueSize: UInt32 = 0

  /// Status of last commit operation
  var lastCommitSuccess: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_DisplayDistanceConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var distanceCm: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_DisplayHeightConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var height: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_ImageTransferComplete: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var streamID: String = String()

  var status: Mentraos_Ble_ImageTransferComplete.Status = .ok

  /// List of missing chunk indices
  var missingChunks: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case ok // = 0
    case incomplete // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .incomplete
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .incomplete: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Mentraos_Ble_ImageTransferComplete.Status] = [
      .ok,
      .incomplete,
    ]

  }

  init() {}
}

struct Mentraos_Ble_ImuEnabledConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_ImuSingleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_ImuStreamConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_ImuData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accel: Mentraos_Ble_Vector3 {
    get {return _accel ?? Mentraos_Ble_Vector3()}
    set {_accel = newValue}
  }
  /// Returns true if `accel` has been explicitly set.
  var hasAccel: Bool {return self._accel != nil}
  /// Clears the value of `accel`. Subsequent reads from it will return its default value.
  mutating func clearAccel() {self._accel = nil}

  var gyro: Mentraos_Ble_Vector3 {
    get {return _gyro ?? Mentraos_Ble_Vector3()}
    set {_gyro = newValue}
  }
  /// Returns true if `gyro` has been explicitly set.
  var hasGyro: Bool {return self._gyro != nil}
  /// Clears the value of `gyro`. Subsequent reads from it will return its default value.
  mutating func clearGyro() {self._gyro = nil}

  var mag: Mentraos_Ble_Vector3 {
    get {return _mag ?? Mentraos_Ble_Vector3()}
    set {_mag = newValue}
  }
  /// Returns true if `mag` has been explicitly set.
  var hasMag: Bool {return self._mag != nil}
  /// Clears the value of `mag`. Subsequent reads from it will return its default value.
  mutating func clearMag() {self._mag = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _accel: Mentraos_Ble_Vector3? = nil
  fileprivate var _gyro: Mentraos_Ble_Vector3? = nil
  fileprivate var _mag: Mentraos_Ble_Vector3? = nil
}

struct Mentraos_Ble_Vector3: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Float = 0

  var y: Float = 0

  var z: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_ButtonEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var button: Mentraos_Ble_ButtonEvent.Button = .leftBack

  var event: Mentraos_Ble_ButtonEvent.Event = .singleTap

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Button: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case leftBack // = 0
    case rightBack // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .leftBack
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .leftBack
      case 1: self = .rightBack
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .leftBack: return 0
      case .rightBack: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Mentraos_Ble_ButtonEvent.Button] = [
      .leftBack,
      .rightBack,
    ]

  }

  enum Event: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case singleTap // = 0
    case doubleTap // = 1
    case tripleTap // = 2
    case longHold // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .singleTap
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .singleTap
      case 1: self = .doubleTap
      case 2: self = .tripleTap
      case 3: self = .longHold
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .singleTap: return 0
      case .doubleTap: return 1
      case .tripleTap: return 2
      case .longHold: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Mentraos_Ble_ButtonEvent.Event] = [
      .singleTap,
      .doubleTap,
      .tripleTap,
      .longHold,
    ]

  }

  init() {}
}

struct Mentraos_Ble_HeadGesture: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gesture: Mentraos_Ble_HeadGesture.Gesture = .nod

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Gesture: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case nod // = 0
    case shake // = 1
    case headUp // = 2
    case headDown // = 3
    case tiltLeft // = 4
    case tiltRight // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .nod
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .nod
      case 1: self = .shake
      case 2: self = .headUp
      case 3: self = .headDown
      case 4: self = .tiltLeft
      case 5: self = .tiltRight
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .nod: return 0
      case .shake: return 1
      case .headUp: return 2
      case .headDown: return 3
      case .tiltLeft: return 4
      case .tiltRight: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Mentraos_Ble_HeadGesture.Gesture] = [
      .nod,
      .shake,
      .headUp,
      .headDown,
      .tiltLeft,
      .tiltRight,
    ]

  }

  init() {}
}

struct Mentraos_Ble_HeadGestureConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gesture: Mentraos_Ble_HeadGesture.Gesture = .nod

  var enabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_RestartRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_FactoryResetRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Cache a complete dashboard/screen that can be triggered instantly
struct Mentraos_Ble_CacheDashboard: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID for this dashboard
  var dashboardID: UInt32 = 0

  /// Series of display commands that make up the dashboard
  /// When dashboard triggers, these commands are queued and committed atomically
  var batch: Mentraos_Ble_DisplayBatch {
    get {return _batch ?? Mentraos_Ble_DisplayBatch()}
    set {_batch = newValue}
  }
  /// Returns true if `batch` has been explicitly set.
  var hasBatch: Bool {return self._batch != nil}
  /// Clears the value of `batch`. Subsequent reads from it will return its default value.
  mutating func clearBatch() {self._batch = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _batch: Mentraos_Ble_DisplayBatch? = nil
}

/// Clear a cached dashboard from memory
struct Mentraos_Ble_ClearDashboard: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dashboardID: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Configure what triggers the dashboard display
struct Mentraos_Ble_ConfigureDashboardTrigger: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dashboardID: UInt32 = 0

  var trigger: Mentraos_Ble_ConfigureDashboardTrigger.TriggerType = .headUp

  /// Optional: minimum duration for gesture (milliseconds)
  var durationMs: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TriggerType: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int

    /// Even Realities style - look up
    case headUp // = 0
    case headDown // = 1

    /// Vuzix Z100 style - tap button
    case buttonTap // = 2

    /// Only show when explicitly commanded
    case manualOnly // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .headUp
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .headUp
      case 1: self = .headDown
      case 2: self = .buttonTap
      case 3: self = .manualOnly
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .headUp: return 0
      case .headDown: return 1
      case .buttonTap: return 2
      case .manualOnly: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Mentraos_Ble_ConfigureDashboardTrigger.TriggerType] = [
      .headUp,
      .headDown,
      .buttonTap,
      .manualOnly,
    ]

  }

  init() {}
}

/// Event sent when dashboard is shown by glasses autonomously
struct Mentraos_Ble_DashboardShown: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dashboardID: UInt32 = 0

  var source: Mentraos_Ble_DashboardShown.TriggerSource = .gesture

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TriggerSource: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case gesture // = 0
    case button // = 1
    case manual // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .gesture
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .gesture
      case 1: self = .button
      case 2: self = .manual
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .gesture: return 0
      case .button: return 1
      case .manual: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Mentraos_Ble_DashboardShown.TriggerSource] = [
      .gesture,
      .button,
      .manual,
    ]

  }

  init() {}
}

/// ============================================
/// Versioning Messages (Runtime)
/// ============================================
///
/// Phone sends VersionRequest right after connect.
/// Glasses respond with VersionResponse.version (single number).
struct Mentraos_Ble_VersionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var msgID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mentraos_Ble_VersionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// echoes request
  var msgID: String = String()

  /// Single, monotonically increasing runtime protocol version.
  /// Start at 1. Bump when wire semantics/behavior meaningfully change.
  var version: UInt32 = 0

  /// Optional diagnostics
  var commit: String = String()

  /// ISO-8601 date string
  var buildDate: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Extension support defined in mentraos_ble.proto.

// MARK: - Extension Properties

// Swift Extensions on the extended Messages to add easy access to the declared
// extension fields. The names are based on the extension field name from the proto
// declaration. To avoid naming collisions, the names are prefixed with the name of
// the scope where the extend directive occurs.

extension SwiftProtobuf.Google_Protobuf_FileOptions {

  /// single, monotonically increasing schema version
  var Mentraos_Ble_mentraSchemaVersion: UInt32 {
    get {return getExtensionValue(ext: Mentraos_Ble_Extensions_mentra_schema_version) ?? 0}
    set {setExtensionValue(ext: Mentraos_Ble_Extensions_mentra_schema_version, value: newValue)}
  }
  /// Returns true if extension `Mentraos_Ble_Extensions_mentra_schema_version`
  /// has been explicitly set.
  var hasMentraos_Ble_mentraSchemaVersion: Bool {
    return hasExtensionValue(ext: Mentraos_Ble_Extensions_mentra_schema_version)
  }
  /// Clears the value of extension `Mentraos_Ble_Extensions_mentra_schema_version`.
  /// Subsequent reads from it will return its default value.
  mutating func clearMentraos_Ble_mentraSchemaVersion() {
    clearExtensionValue(ext: Mentraos_Ble_Extensions_mentra_schema_version)
  }

}

// MARK: - File's ExtensionMap: Mentraos_Ble_MentraosBle_Extensions

/// A `SwiftProtobuf.SimpleExtensionMap` that includes all of the extensions defined by
/// this .proto file. It can be used any place an `SwiftProtobuf.ExtensionMap` is needed
/// in parsing, or it can be combined with other `SwiftProtobuf.SimpleExtensionMap`s to create
/// a larger `SwiftProtobuf.SimpleExtensionMap`.
let Mentraos_Ble_MentraosBle_Extensions: SwiftProtobuf.SimpleExtensionMap = [
  Mentraos_Ble_Extensions_mentra_schema_version
]

// Extension Objects - The only reason these might be needed is when manually
// constructing a `SimpleExtensionMap`, otherwise, use the above _Extension Properties_
// accessors for the extension fields on the messages directly.

/// single, monotonically increasing schema version
let Mentraos_Ble_Extensions_mentra_schema_version = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufUInt32>, SwiftProtobuf.Google_Protobuf_FileOptions>(
  _protobuf_fieldNumber: 70001,
  fieldName: "mentraos.ble.mentra_schema_version"
)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "mentraos.ble"

extension Mentraos_Ble_PhoneToGlasses: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PhoneToGlasses"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}msg_id\0\u{2}\u{9}disconnect\0\u{3}battery_state\0\u{3}glasses_info\0\u{3}pairing_mode\0\u{3}head_position\0\u{3}head_up_angle\0\u{1}pong\0\u{4}\u{4}mic_state\0\u{4}\u{3}set_vad_enabled\0\u{3}set_vad_config\0\u{3}request_vad_status\0\u{4}\u{5}display_text\0\u{3}display_image\0\u{3}cache_image\0\u{3}display_cached_image\0\u{3}clear_cached_image\0\u{3}display_scrolling_text\0\u{3}display_power\0\u{1}brightness\0\u{3}auto_brightness\0\u{3}auto_brightness_mult\0\u{3}draw_line\0\u{3}draw_rect\0\u{3}draw_circle\0\u{1}commit\0\u{3}display_distance\0\u{3}display_height\0\u{3}clear_display\0\u{3}cache_dashboard\0\u{3}clear_dashboard\0\u{3}dashboard_trigger\0\u{4}\u{2}queue_status_request\0\u{3}display_batch\0\u{4}\u{3}imu_enabled\0\u{3}imu_single\0\u{3}imu_stream\0\u{3}head_gesture\0\u{2}\u{2}restart\0\u{3}factory_reset\0\u{4}\u{9}version_request\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.msgID) }()
      case 10: try {
        var v: Mentraos_Ble_DisconnectRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .disconnect(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .disconnect(v)
        }
      }()
      case 11: try {
        var v: Mentraos_Ble_BatteryStateRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .batteryState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .batteryState(v)
        }
      }()
      case 12: try {
        var v: Mentraos_Ble_GlassesInfoRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .glassesInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .glassesInfo(v)
        }
      }()
      case 13: try {
        var v: Mentraos_Ble_PairingModeRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .pairingMode(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .pairingMode(v)
        }
      }()
      case 14: try {
        var v: Mentraos_Ble_HeadPositionRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .headPosition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .headPosition(v)
        }
      }()
      case 15: try {
        var v: Mentraos_Ble_HeadUpAngleConfig?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .headUpAngle(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .headUpAngle(v)
        }
      }()
      case 16: try {
        var v: Mentraos_Ble_PongResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .pong(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .pong(v)
        }
      }()
      case 20: try {
        var v: Mentraos_Ble_MicStateConfig?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .micState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .micState(v)
        }
      }()
      case 23: try {
        var v: Mentraos_Ble_VadEnabledRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .setVadEnabled(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .setVadEnabled(v)
        }
      }()
      case 24: try {
        var v: Mentraos_Ble_VadConfigRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .setVadConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .setVadConfig(v)
        }
      }()
      case 25: try {
        var v: Mentraos_Ble_VadStatusRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .requestVadStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .requestVadStatus(v)
        }
      }()
      case 30: try {
        var v: Mentraos_Ble_DisplayText?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .displayText(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .displayText(v)
        }
      }()
      case 31: try {
        var v: Mentraos_Ble_DisplayImage?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .displayImage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .displayImage(v)
        }
      }()
      case 32: try {
        var v: Mentraos_Ble_CacheImage?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .cacheImage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .cacheImage(v)
        }
      }()
      case 33: try {
        var v: Mentraos_Ble_DisplayCachedImage?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .displayCachedImage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .displayCachedImage(v)
        }
      }()
      case 34: try {
        var v: Mentraos_Ble_ClearCachedImage?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .clearCachedImage_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .clearCachedImage_p(v)
        }
      }()
      case 35: try {
        var v: Mentraos_Ble_DisplayScrollingText?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .displayScrollingText(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .displayScrollingText(v)
        }
      }()
      case 36: try {
        var v: Mentraos_Ble_DisplayPowerConfig?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .displayPower(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .displayPower(v)
        }
      }()
      case 37: try {
        var v: Mentraos_Ble_BrightnessConfig?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .brightness(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .brightness(v)
        }
      }()
      case 38: try {
        var v: Mentraos_Ble_AutoBrightnessConfig?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .autoBrightness(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .autoBrightness(v)
        }
      }()
      case 39: try {
        var v: Mentraos_Ble_AutoBrightnessMultiplier?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .autoBrightnessMult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .autoBrightnessMult(v)
        }
      }()
      case 40: try {
        var v: Mentraos_Ble_DrawLine?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .drawLine(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .drawLine(v)
        }
      }()
      case 41: try {
        var v: Mentraos_Ble_DrawRect?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .drawRect(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .drawRect(v)
        }
      }()
      case 42: try {
        var v: Mentraos_Ble_DrawCircle?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .drawCircle(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .drawCircle(v)
        }
      }()
      case 43: try {
        var v: Mentraos_Ble_CommitDisplay?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .commit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .commit(v)
        }
      }()
      case 44: try {
        var v: Mentraos_Ble_DisplayDistanceConfig?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .displayDistance(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .displayDistance(v)
        }
      }()
      case 45: try {
        var v: Mentraos_Ble_DisplayHeightConfig?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .displayHeight(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .displayHeight(v)
        }
      }()
      case 46: try {
        var v: Mentraos_Ble_ClearDisplay?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .clearDisplay_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .clearDisplay_p(v)
        }
      }()
      case 47: try {
        var v: Mentraos_Ble_CacheDashboard?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .cacheDashboard(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .cacheDashboard(v)
        }
      }()
      case 48: try {
        var v: Mentraos_Ble_ClearDashboard?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .clearDashboard_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .clearDashboard_p(v)
        }
      }()
      case 49: try {
        var v: Mentraos_Ble_ConfigureDashboardTrigger?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .dashboardTrigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .dashboardTrigger(v)
        }
      }()
      case 51: try {
        var v: Mentraos_Ble_DisplayQueueStatus?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .queueStatusRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .queueStatusRequest(v)
        }
      }()
      case 52: try {
        var v: Mentraos_Ble_DisplayBatch?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .displayBatch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .displayBatch(v)
        }
      }()
      case 55: try {
        var v: Mentraos_Ble_ImuEnabledConfig?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .imuEnabled(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .imuEnabled(v)
        }
      }()
      case 56: try {
        var v: Mentraos_Ble_ImuSingleRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .imuSingle(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .imuSingle(v)
        }
      }()
      case 57: try {
        var v: Mentraos_Ble_ImuStreamConfig?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .imuStream(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .imuStream(v)
        }
      }()
      case 58: try {
        var v: Mentraos_Ble_HeadGestureConfig?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .headGesture(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .headGesture(v)
        }
      }()
      case 60: try {
        var v: Mentraos_Ble_RestartRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .restart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .restart(v)
        }
      }()
      case 61: try {
        var v: Mentraos_Ble_FactoryResetRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .factoryReset(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .factoryReset(v)
        }
      }()
      case 70: try {
        var v: Mentraos_Ble_VersionRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .versionRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .versionRequest(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.msgID.isEmpty {
      try visitor.visitSingularStringField(value: self.msgID, fieldNumber: 1)
    }
    switch self.payload {
    case .disconnect?: try {
      guard case .disconnect(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .batteryState?: try {
      guard case .batteryState(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .glassesInfo?: try {
      guard case .glassesInfo(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .pairingMode?: try {
      guard case .pairingMode(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .headPosition?: try {
      guard case .headPosition(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .headUpAngle?: try {
      guard case .headUpAngle(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .pong?: try {
      guard case .pong(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .micState?: try {
      guard case .micState(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .setVadEnabled?: try {
      guard case .setVadEnabled(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .setVadConfig?: try {
      guard case .setVadConfig(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case .requestVadStatus?: try {
      guard case .requestVadStatus(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case .displayText?: try {
      guard case .displayText(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .displayImage?: try {
      guard case .displayImage(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case .cacheImage?: try {
      guard case .cacheImage(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case .displayCachedImage?: try {
      guard case .displayCachedImage(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
    }()
    case .clearCachedImage_p?: try {
      guard case .clearCachedImage_p(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
    }()
    case .displayScrollingText?: try {
      guard case .displayScrollingText(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
    }()
    case .displayPower?: try {
      guard case .displayPower(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
    }()
    case .brightness?: try {
      guard case .brightness(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
    }()
    case .autoBrightness?: try {
      guard case .autoBrightness(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
    }()
    case .autoBrightnessMult?: try {
      guard case .autoBrightnessMult(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
    }()
    case .drawLine?: try {
      guard case .drawLine(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
    }()
    case .drawRect?: try {
      guard case .drawRect(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
    }()
    case .drawCircle?: try {
      guard case .drawCircle(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
    }()
    case .commit?: try {
      guard case .commit(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
    }()
    case .displayDistance?: try {
      guard case .displayDistance(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
    }()
    case .displayHeight?: try {
      guard case .displayHeight(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
    }()
    case .clearDisplay_p?: try {
      guard case .clearDisplay_p(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
    }()
    case .cacheDashboard?: try {
      guard case .cacheDashboard(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
    }()
    case .clearDashboard_p?: try {
      guard case .clearDashboard_p(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
    }()
    case .dashboardTrigger?: try {
      guard case .dashboardTrigger(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
    }()
    case .queueStatusRequest?: try {
      guard case .queueStatusRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
    }()
    case .displayBatch?: try {
      guard case .displayBatch(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
    }()
    case .imuEnabled?: try {
      guard case .imuEnabled(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 55)
    }()
    case .imuSingle?: try {
      guard case .imuSingle(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 56)
    }()
    case .imuStream?: try {
      guard case .imuStream(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 57)
    }()
    case .headGesture?: try {
      guard case .headGesture(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 58)
    }()
    case .restart?: try {
      guard case .restart(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 60)
    }()
    case .factoryReset?: try {
      guard case .factoryReset(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
    }()
    case .versionRequest?: try {
      guard case .versionRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 70)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_PhoneToGlasses, rhs: Mentraos_Ble_PhoneToGlasses) -> Bool {
    if lhs.msgID != rhs.msgID {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_GlassesToPhone: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GlassesToPhone"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{4}\u{a}battery_status\0\u{3}charging_state\0\u{3}device_info\0\u{3}head_position\0\u{3}head_up_angle_set\0\u{1}ping\0\u{4}\u{5}vad_event\0\u{3}vad_enabled_set\0\u{3}vad_configured\0\u{3}vad_status\0\u{4}\u{7}image_transfer_complete\0\u{3}display_queue_info\0\u{4}\u{9}imu_data\0\u{3}button_event\0\u{3}head_gesture\0\u{3}dashboard_shown\0\u{4}\u{1b}version_response\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 10: try {
        var v: Mentraos_Ble_BatteryStatus?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .batteryStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .batteryStatus(v)
        }
      }()
      case 11: try {
        var v: Mentraos_Ble_ChargingState?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .chargingState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .chargingState(v)
        }
      }()
      case 12: try {
        var v: Mentraos_Ble_DeviceInfo?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .deviceInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .deviceInfo(v)
        }
      }()
      case 13: try {
        var v: Mentraos_Ble_HeadPosition?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .headPosition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .headPosition(v)
        }
      }()
      case 14: try {
        var v: Mentraos_Ble_HeadUpAngleResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .headUpAngleSet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .headUpAngleSet(v)
        }
      }()
      case 15: try {
        var v: Mentraos_Ble_PingRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .ping(v)
        }
      }()
      case 20: try {
        var v: Mentraos_Ble_VadEvent?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .vadEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .vadEvent(v)
        }
      }()
      case 21: try {
        var v: Mentraos_Ble_VadEnabledResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .vadEnabledSet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .vadEnabledSet(v)
        }
      }()
      case 22: try {
        var v: Mentraos_Ble_VadConfigResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .vadConfigured(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .vadConfigured(v)
        }
      }()
      case 23: try {
        var v: Mentraos_Ble_VadStatus?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .vadStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .vadStatus(v)
        }
      }()
      case 30: try {
        var v: Mentraos_Ble_ImageTransferComplete?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .imageTransferComplete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .imageTransferComplete(v)
        }
      }()
      case 31: try {
        var v: Mentraos_Ble_DisplayQueueInfo?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .displayQueueInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .displayQueueInfo(v)
        }
      }()
      case 40: try {
        var v: Mentraos_Ble_ImuData?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .imuData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .imuData(v)
        }
      }()
      case 41: try {
        var v: Mentraos_Ble_ButtonEvent?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .buttonEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .buttonEvent(v)
        }
      }()
      case 42: try {
        var v: Mentraos_Ble_HeadGesture?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .headGesture(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .headGesture(v)
        }
      }()
      case 43: try {
        var v: Mentraos_Ble_DashboardShown?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .dashboardShown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .dashboardShown(v)
        }
      }()
      case 70: try {
        var v: Mentraos_Ble_VersionResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .versionResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .versionResponse(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .batteryStatus?: try {
      guard case .batteryStatus(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .chargingState?: try {
      guard case .chargingState(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .deviceInfo?: try {
      guard case .deviceInfo(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .headPosition?: try {
      guard case .headPosition(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .headUpAngleSet?: try {
      guard case .headUpAngleSet(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .ping?: try {
      guard case .ping(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .vadEvent?: try {
      guard case .vadEvent(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .vadEnabledSet?: try {
      guard case .vadEnabledSet(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .vadConfigured?: try {
      guard case .vadConfigured(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .vadStatus?: try {
      guard case .vadStatus(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .imageTransferComplete?: try {
      guard case .imageTransferComplete(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .displayQueueInfo?: try {
      guard case .displayQueueInfo(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case .imuData?: try {
      guard case .imuData(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
    }()
    case .buttonEvent?: try {
      guard case .buttonEvent(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
    }()
    case .headGesture?: try {
      guard case .headGesture(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
    }()
    case .dashboardShown?: try {
      guard case .dashboardShown(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
    }()
    case .versionResponse?: try {
      guard case .versionResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 70)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_GlassesToPhone, rhs: Mentraos_Ble_GlassesToPhone) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_DisconnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisconnectRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_DisconnectRequest, rhs: Mentraos_Ble_DisconnectRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_BatteryStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatteryStateRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_BatteryStateRequest, rhs: Mentraos_Ble_BatteryStateRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_BatteryStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatteryStatus"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}level\0\u{1}charging\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.level) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.charging) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.level != 0 {
      try visitor.visitSingularUInt32Field(value: self.level, fieldNumber: 1)
    }
    if self.charging != false {
      try visitor.visitSingularBoolField(value: self.charging, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_BatteryStatus, rhs: Mentraos_Ble_BatteryStatus) -> Bool {
    if lhs.level != rhs.level {return false}
    if lhs.charging != rhs.charging {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_ChargingState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargingState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}state\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.state != .notCharging {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_ChargingState, rhs: Mentraos_Ble_ChargingState) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_ChargingState.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0NOT_CHARGING\0\u{1}CHARGING\0")
}

extension Mentraos_Ble_GlassesInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GlassesInfoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_GlassesInfoRequest, rhs: Mentraos_Ble_GlassesInfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_DeviceInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeviceInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}fw_version\0\u{3}hw_model\0\u{1}features\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fwVersion) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.hwModel) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._features) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.fwVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.fwVersion, fieldNumber: 1)
    }
    if !self.hwModel.isEmpty {
      try visitor.visitSingularStringField(value: self.hwModel, fieldNumber: 2)
    }
    try { if let v = self._features {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_DeviceInfo, rhs: Mentraos_Ble_DeviceInfo) -> Bool {
    if lhs.fwVersion != rhs.fwVersion {return false}
    if lhs.hwModel != rhs.hwModel {return false}
    if lhs._features != rhs._features {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_DeviceFeatures: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeviceFeatures"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}camera\0\u{1}display\0\u{3}audio_tx\0\u{3}audio_rx\0\u{1}imu\0\u{1}vad\0\u{3}mic_switching\0\u{3}image_chunk_buffer\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.camera) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.display) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.audioTx) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.audioRx) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.imu) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.vad) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.micSwitching) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.imageChunkBuffer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.camera != false {
      try visitor.visitSingularBoolField(value: self.camera, fieldNumber: 1)
    }
    if self.display != false {
      try visitor.visitSingularBoolField(value: self.display, fieldNumber: 2)
    }
    if self.audioTx != false {
      try visitor.visitSingularBoolField(value: self.audioTx, fieldNumber: 3)
    }
    if self.audioRx != false {
      try visitor.visitSingularBoolField(value: self.audioRx, fieldNumber: 4)
    }
    if self.imu != false {
      try visitor.visitSingularBoolField(value: self.imu, fieldNumber: 5)
    }
    if self.vad != false {
      try visitor.visitSingularBoolField(value: self.vad, fieldNumber: 6)
    }
    if self.micSwitching != false {
      try visitor.visitSingularBoolField(value: self.micSwitching, fieldNumber: 7)
    }
    if self.imageChunkBuffer != 0 {
      try visitor.visitSingularUInt32Field(value: self.imageChunkBuffer, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_DeviceFeatures, rhs: Mentraos_Ble_DeviceFeatures) -> Bool {
    if lhs.camera != rhs.camera {return false}
    if lhs.display != rhs.display {return false}
    if lhs.audioTx != rhs.audioTx {return false}
    if lhs.audioRx != rhs.audioRx {return false}
    if lhs.imu != rhs.imu {return false}
    if lhs.vad != rhs.vad {return false}
    if lhs.micSwitching != rhs.micSwitching {return false}
    if lhs.imageChunkBuffer != rhs.imageChunkBuffer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_PairingModeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PairingModeRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_PairingModeRequest, rhs: Mentraos_Ble_PairingModeRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_HeadPositionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HeadPositionRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_HeadPositionRequest, rhs: Mentraos_Ble_HeadPositionRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_HeadPosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HeadPosition"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}angle\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.angle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.angle != 0 {
      try visitor.visitSingularInt32Field(value: self.angle, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_HeadPosition, rhs: Mentraos_Ble_HeadPosition) -> Bool {
    if lhs.angle != rhs.angle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_HeadUpAngleConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HeadUpAngleConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}angle\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.angle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.angle != 0 {
      try visitor.visitSingularUInt32Field(value: self.angle, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_HeadUpAngleConfig, rhs: Mentraos_Ble_HeadUpAngleConfig) -> Bool {
    if lhs.angle != rhs.angle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_HeadUpAngleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HeadUpAngleResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_HeadUpAngleResponse, rhs: Mentraos_Ble_HeadUpAngleResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_PingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PingRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}msg_id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.msgID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.msgID.isEmpty {
      try visitor.visitSingularStringField(value: self.msgID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_PingRequest, rhs: Mentraos_Ble_PingRequest) -> Bool {
    if lhs.msgID != rhs.msgID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_PongResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PongResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_PongResponse, rhs: Mentraos_Ble_PongResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_MicStateConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MicStateConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}enabled\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_MicStateConfig, rhs: Mentraos_Ble_MicStateConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_VadEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VadEvent"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}state\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.state != .inactive {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_VadEvent, rhs: Mentraos_Ble_VadEvent) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_VadEvent.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0INACTIVE\0\u{1}ACTIVE\0")
}

extension Mentraos_Ble_VadEnabledRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VadEnabledRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}msg_id\0\u{1}enabled\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.msgID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.msgID.isEmpty {
      try visitor.visitSingularStringField(value: self.msgID, fieldNumber: 1)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_VadEnabledRequest, rhs: Mentraos_Ble_VadEnabledRequest) -> Bool {
    if lhs.msgID != rhs.msgID {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_VadEnabledResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VadEnabledResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}msg_id\0\u{1}success\0\u{1}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.msgID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.msgID.isEmpty {
      try visitor.visitSingularStringField(value: self.msgID, fieldNumber: 1)
    }
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 2)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_VadEnabledResponse, rhs: Mentraos_Ble_VadEnabledResponse) -> Bool {
    if lhs.msgID != rhs.msgID {return false}
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_VadConfigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VadConfigRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}msg_id\0\u{1}sensitivity\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.msgID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.sensitivity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.msgID.isEmpty {
      try visitor.visitSingularStringField(value: self.msgID, fieldNumber: 1)
    }
    if self.sensitivity != 0 {
      try visitor.visitSingularUInt32Field(value: self.sensitivity, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_VadConfigRequest, rhs: Mentraos_Ble_VadConfigRequest) -> Bool {
    if lhs.msgID != rhs.msgID {return false}
    if lhs.sensitivity != rhs.sensitivity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_VadConfigResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VadConfigResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}msg_id\0\u{1}success\0\u{1}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.msgID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.msgID.isEmpty {
      try visitor.visitSingularStringField(value: self.msgID, fieldNumber: 1)
    }
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 2)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_VadConfigResponse, rhs: Mentraos_Ble_VadConfigResponse) -> Bool {
    if lhs.msgID != rhs.msgID {return false}
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_VadStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VadStatusRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}msg_id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.msgID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.msgID.isEmpty {
      try visitor.visitSingularStringField(value: self.msgID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_VadStatusRequest, rhs: Mentraos_Ble_VadStatusRequest) -> Bool {
    if lhs.msgID != rhs.msgID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_VadStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VadStatus"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}msg_id\0\u{1}enabled\0\u{1}sensitivity\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.msgID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.sensitivity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.msgID.isEmpty {
      try visitor.visitSingularStringField(value: self.msgID, fieldNumber: 1)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 2)
    }
    if self.sensitivity != 0 {
      try visitor.visitSingularUInt32Field(value: self.sensitivity, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_VadStatus, rhs: Mentraos_Ble_VadStatus) -> Bool {
    if lhs.msgID != rhs.msgID {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.sensitivity != rhs.sensitivity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_DisplayText: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisplayText"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}text\0\u{1}color\0\u{1}x\0\u{1}y\0\u{1}size\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.color) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.x) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.y) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.size) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if self.color != 0 {
      try visitor.visitSingularUInt32Field(value: self.color, fieldNumber: 2)
    }
    if self.x != 0 {
      try visitor.visitSingularUInt32Field(value: self.x, fieldNumber: 3)
    }
    if self.y != 0 {
      try visitor.visitSingularUInt32Field(value: self.y, fieldNumber: 4)
    }
    if self.size != 0 {
      try visitor.visitSingularUInt32Field(value: self.size, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_DisplayText, rhs: Mentraos_Ble_DisplayText) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.color != rhs.color {return false}
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.size != rhs.size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_DisplayImage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisplayImage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}stream_id\0\u{1}x\0\u{1}y\0\u{1}width\0\u{1}height\0\u{1}encoding\0\u{3}total_chunks\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.streamID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.x) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.y) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.width) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.height) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.encoding) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.totalChunks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.streamID.isEmpty {
      try visitor.visitSingularStringField(value: self.streamID, fieldNumber: 1)
    }
    if self.x != 0 {
      try visitor.visitSingularUInt32Field(value: self.x, fieldNumber: 2)
    }
    if self.y != 0 {
      try visitor.visitSingularUInt32Field(value: self.y, fieldNumber: 3)
    }
    if self.width != 0 {
      try visitor.visitSingularUInt32Field(value: self.width, fieldNumber: 4)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt32Field(value: self.height, fieldNumber: 5)
    }
    if !self.encoding.isEmpty {
      try visitor.visitSingularStringField(value: self.encoding, fieldNumber: 6)
    }
    if self.totalChunks != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalChunks, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_DisplayImage, rhs: Mentraos_Ble_DisplayImage) -> Bool {
    if lhs.streamID != rhs.streamID {return false}
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.encoding != rhs.encoding {return false}
    if lhs.totalChunks != rhs.totalChunks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_CacheImage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CacheImage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}stream_id\0\u{3}image_id\0\u{1}width\0\u{1}height\0\u{1}encoding\0\u{3}total_chunks\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.streamID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.imageID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.width) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.height) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.encoding) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.totalChunks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.streamID.isEmpty {
      try visitor.visitSingularStringField(value: self.streamID, fieldNumber: 1)
    }
    if self.imageID != 0 {
      try visitor.visitSingularUInt32Field(value: self.imageID, fieldNumber: 2)
    }
    if self.width != 0 {
      try visitor.visitSingularUInt32Field(value: self.width, fieldNumber: 3)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt32Field(value: self.height, fieldNumber: 4)
    }
    if !self.encoding.isEmpty {
      try visitor.visitSingularStringField(value: self.encoding, fieldNumber: 5)
    }
    if self.totalChunks != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalChunks, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_CacheImage, rhs: Mentraos_Ble_CacheImage) -> Bool {
    if lhs.streamID != rhs.streamID {return false}
    if lhs.imageID != rhs.imageID {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.encoding != rhs.encoding {return false}
    if lhs.totalChunks != rhs.totalChunks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_DisplayCachedImage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisplayCachedImage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}image_id\0\u{1}x\0\u{1}y\0\u{1}width\0\u{1}height\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.imageID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.x) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.y) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.width) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.height) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.imageID != 0 {
      try visitor.visitSingularUInt32Field(value: self.imageID, fieldNumber: 1)
    }
    if self.x != 0 {
      try visitor.visitSingularUInt32Field(value: self.x, fieldNumber: 2)
    }
    if self.y != 0 {
      try visitor.visitSingularUInt32Field(value: self.y, fieldNumber: 3)
    }
    if self.width != 0 {
      try visitor.visitSingularUInt32Field(value: self.width, fieldNumber: 4)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt32Field(value: self.height, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_DisplayCachedImage, rhs: Mentraos_Ble_DisplayCachedImage) -> Bool {
    if lhs.imageID != rhs.imageID {return false}
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_ClearCachedImage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClearCachedImage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}image_id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.imageID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.imageID != 0 {
      try visitor.visitSingularUInt32Field(value: self.imageID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_ClearCachedImage, rhs: Mentraos_Ble_ClearCachedImage) -> Bool {
    if lhs.imageID != rhs.imageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_DisplayScrollingText: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisplayScrollingText"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}text\0\u{1}color\0\u{1}x\0\u{1}y\0\u{1}width\0\u{1}height\0\u{1}align\0\u{3}line_spacing\0\u{1}speed\0\u{1}size\0\u{1}loop\0\u{3}pause_ms\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.color) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.x) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.y) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.width) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.height) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.align) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.lineSpacing) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.speed) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self.size) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.loop) }()
      case 12: try { try decoder.decodeSingularUInt32Field(value: &self.pauseMs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if self.color != 0 {
      try visitor.visitSingularUInt32Field(value: self.color, fieldNumber: 2)
    }
    if self.x != 0 {
      try visitor.visitSingularUInt32Field(value: self.x, fieldNumber: 3)
    }
    if self.y != 0 {
      try visitor.visitSingularUInt32Field(value: self.y, fieldNumber: 4)
    }
    if self.width != 0 {
      try visitor.visitSingularUInt32Field(value: self.width, fieldNumber: 5)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt32Field(value: self.height, fieldNumber: 6)
    }
    if self.align != .left {
      try visitor.visitSingularEnumField(value: self.align, fieldNumber: 7)
    }
    if self.lineSpacing != 0 {
      try visitor.visitSingularUInt32Field(value: self.lineSpacing, fieldNumber: 8)
    }
    if self.speed != 0 {
      try visitor.visitSingularUInt32Field(value: self.speed, fieldNumber: 9)
    }
    if self.size != 0 {
      try visitor.visitSingularUInt32Field(value: self.size, fieldNumber: 10)
    }
    if self.loop != false {
      try visitor.visitSingularBoolField(value: self.loop, fieldNumber: 11)
    }
    if self.pauseMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.pauseMs, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_DisplayScrollingText, rhs: Mentraos_Ble_DisplayScrollingText) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.color != rhs.color {return false}
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.align != rhs.align {return false}
    if lhs.lineSpacing != rhs.lineSpacing {return false}
    if lhs.speed != rhs.speed {return false}
    if lhs.size != rhs.size {return false}
    if lhs.loop != rhs.loop {return false}
    if lhs.pauseMs != rhs.pauseMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_DisplayScrollingText.Alignment: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0LEFT\0\u{1}CENTER\0\u{1}RIGHT\0")
}

extension Mentraos_Ble_DisplayPowerConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisplayPowerConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}on\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.on) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.on != false {
      try visitor.visitSingularBoolField(value: self.on, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_DisplayPowerConfig, rhs: Mentraos_Ble_DisplayPowerConfig) -> Bool {
    if lhs.on != rhs.on {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_BrightnessConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BrightnessConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt32Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_BrightnessConfig, rhs: Mentraos_Ble_BrightnessConfig) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_AutoBrightnessConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AutoBrightnessConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}enabled\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_AutoBrightnessConfig, rhs: Mentraos_Ble_AutoBrightnessConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_AutoBrightnessMultiplier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AutoBrightnessMultiplier"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}multiplier\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.multiplier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.multiplier.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.multiplier, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_AutoBrightnessMultiplier, rhs: Mentraos_Ble_AutoBrightnessMultiplier) -> Bool {
    if lhs.multiplier != rhs.multiplier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_DrawLine: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DrawLine"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}color\0\u{1}stroke\0\u{1}x1\0\u{1}y1\0\u{1}x2\0\u{1}y2\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.color) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.stroke) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.x1) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.y1) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.x2) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.y2) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.color != 0 {
      try visitor.visitSingularUInt32Field(value: self.color, fieldNumber: 1)
    }
    if self.stroke != 0 {
      try visitor.visitSingularUInt32Field(value: self.stroke, fieldNumber: 2)
    }
    if self.x1 != 0 {
      try visitor.visitSingularUInt32Field(value: self.x1, fieldNumber: 3)
    }
    if self.y1 != 0 {
      try visitor.visitSingularUInt32Field(value: self.y1, fieldNumber: 4)
    }
    if self.x2 != 0 {
      try visitor.visitSingularUInt32Field(value: self.x2, fieldNumber: 5)
    }
    if self.y2 != 0 {
      try visitor.visitSingularUInt32Field(value: self.y2, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_DrawLine, rhs: Mentraos_Ble_DrawLine) -> Bool {
    if lhs.color != rhs.color {return false}
    if lhs.stroke != rhs.stroke {return false}
    if lhs.x1 != rhs.x1 {return false}
    if lhs.y1 != rhs.y1 {return false}
    if lhs.x2 != rhs.x2 {return false}
    if lhs.y2 != rhs.y2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_DrawRect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DrawRect"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}color\0\u{1}stroke\0\u{1}x\0\u{1}y\0\u{1}width\0\u{1}height\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.color) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.stroke) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.x) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.y) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.width) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.height) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.color != 0 {
      try visitor.visitSingularUInt32Field(value: self.color, fieldNumber: 1)
    }
    if self.stroke != 0 {
      try visitor.visitSingularUInt32Field(value: self.stroke, fieldNumber: 2)
    }
    if self.x != 0 {
      try visitor.visitSingularUInt32Field(value: self.x, fieldNumber: 3)
    }
    if self.y != 0 {
      try visitor.visitSingularUInt32Field(value: self.y, fieldNumber: 4)
    }
    if self.width != 0 {
      try visitor.visitSingularUInt32Field(value: self.width, fieldNumber: 5)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt32Field(value: self.height, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_DrawRect, rhs: Mentraos_Ble_DrawRect) -> Bool {
    if lhs.color != rhs.color {return false}
    if lhs.stroke != rhs.stroke {return false}
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_DrawCircle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DrawCircle"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}color\0\u{1}stroke\0\u{1}x\0\u{1}y\0\u{1}radius\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.color) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.stroke) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.x) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.y) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.radius) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.color != 0 {
      try visitor.visitSingularUInt32Field(value: self.color, fieldNumber: 1)
    }
    if self.stroke != 0 {
      try visitor.visitSingularUInt32Field(value: self.stroke, fieldNumber: 2)
    }
    if self.x != 0 {
      try visitor.visitSingularUInt32Field(value: self.x, fieldNumber: 3)
    }
    if self.y != 0 {
      try visitor.visitSingularUInt32Field(value: self.y, fieldNumber: 4)
    }
    if self.radius != 0 {
      try visitor.visitSingularUInt32Field(value: self.radius, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_DrawCircle, rhs: Mentraos_Ble_DrawCircle) -> Bool {
    if lhs.color != rhs.color {return false}
    if lhs.stroke != rhs.stroke {return false}
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.radius != rhs.radius {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_DisplayBatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisplayBatch"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}commands\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.commands) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.commands.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.commands, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_DisplayBatch, rhs: Mentraos_Ble_DisplayBatch) -> Bool {
    if lhs.commands != rhs.commands {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_DisplayBatch.DisplayCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Mentraos_Ble_DisplayBatch.protoMessageName + ".DisplayCommand"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}text\0\u{3}cached_image\0\u{1}line\0\u{1}rect\0\u{1}circle\0\u{3}scrolling_text\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Mentraos_Ble_DisplayText?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .text(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .text(v)
        }
      }()
      case 2: try {
        var v: Mentraos_Ble_DisplayCachedImage?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .cachedImage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .cachedImage(v)
        }
      }()
      case 3: try {
        var v: Mentraos_Ble_DrawLine?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .line(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .line(v)
        }
      }()
      case 4: try {
        var v: Mentraos_Ble_DrawRect?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .rect(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .rect(v)
        }
      }()
      case 5: try {
        var v: Mentraos_Ble_DrawCircle?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .circle(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .circle(v)
        }
      }()
      case 6: try {
        var v: Mentraos_Ble_DisplayScrollingText?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .scrollingText(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .scrollingText(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.command {
    case .text?: try {
      guard case .text(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .cachedImage?: try {
      guard case .cachedImage(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .line?: try {
      guard case .line(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .rect?: try {
      guard case .rect(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .circle?: try {
      guard case .circle(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .scrollingText?: try {
      guard case .scrollingText(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_DisplayBatch.DisplayCommand, rhs: Mentraos_Ble_DisplayBatch.DisplayCommand) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_CommitDisplay: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommitDisplay"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}clear_before\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.clearBefore_p) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.clearBefore_p != false {
      try visitor.visitSingularBoolField(value: self.clearBefore_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_CommitDisplay, rhs: Mentraos_Ble_CommitDisplay) -> Bool {
    if lhs.clearBefore_p != rhs.clearBefore_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_ClearDisplay: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClearDisplay"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_ClearDisplay, rhs: Mentraos_Ble_ClearDisplay) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_DisplayQueueStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisplayQueueStatus"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_DisplayQueueStatus, rhs: Mentraos_Ble_DisplayQueueStatus) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_DisplayQueueInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisplayQueueInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}queued_commands\0\u{3}queue_bytes\0\u{3}max_queue_size\0\u{3}last_commit_success\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.queuedCommands) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.queueBytes) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.maxQueueSize) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.lastCommitSuccess) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.queuedCommands != 0 {
      try visitor.visitSingularUInt32Field(value: self.queuedCommands, fieldNumber: 1)
    }
    if self.queueBytes != 0 {
      try visitor.visitSingularUInt32Field(value: self.queueBytes, fieldNumber: 2)
    }
    if self.maxQueueSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxQueueSize, fieldNumber: 3)
    }
    if self.lastCommitSuccess != false {
      try visitor.visitSingularBoolField(value: self.lastCommitSuccess, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_DisplayQueueInfo, rhs: Mentraos_Ble_DisplayQueueInfo) -> Bool {
    if lhs.queuedCommands != rhs.queuedCommands {return false}
    if lhs.queueBytes != rhs.queueBytes {return false}
    if lhs.maxQueueSize != rhs.maxQueueSize {return false}
    if lhs.lastCommitSuccess != rhs.lastCommitSuccess {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_DisplayDistanceConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisplayDistanceConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}distance_cm\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.distanceCm) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.distanceCm != 0 {
      try visitor.visitSingularUInt32Field(value: self.distanceCm, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_DisplayDistanceConfig, rhs: Mentraos_Ble_DisplayDistanceConfig) -> Bool {
    if lhs.distanceCm != rhs.distanceCm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_DisplayHeightConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisplayHeightConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}height\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.height) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.height != 0 {
      try visitor.visitSingularUInt32Field(value: self.height, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_DisplayHeightConfig, rhs: Mentraos_Ble_DisplayHeightConfig) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_ImageTransferComplete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImageTransferComplete"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}stream_id\0\u{1}status\0\u{3}missing_chunks\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.streamID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 3: try { try decoder.decodeRepeatedUInt32Field(value: &self.missingChunks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.streamID.isEmpty {
      try visitor.visitSingularStringField(value: self.streamID, fieldNumber: 1)
    }
    if self.status != .ok {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if !self.missingChunks.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.missingChunks, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_ImageTransferComplete, rhs: Mentraos_Ble_ImageTransferComplete) -> Bool {
    if lhs.streamID != rhs.streamID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.missingChunks != rhs.missingChunks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_ImageTransferComplete.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0OK\0\u{1}INCOMPLETE\0")
}

extension Mentraos_Ble_ImuEnabledConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImuEnabledConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}enabled\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_ImuEnabledConfig, rhs: Mentraos_Ble_ImuEnabledConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_ImuSingleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImuSingleRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_ImuSingleRequest, rhs: Mentraos_Ble_ImuSingleRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_ImuStreamConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImuStreamConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}enabled\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_ImuStreamConfig, rhs: Mentraos_Ble_ImuStreamConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_ImuData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImuData"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}accel\0\u{1}gyro\0\u{1}mag\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._accel) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._gyro) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._mag) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._accel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._gyro {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._mag {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_ImuData, rhs: Mentraos_Ble_ImuData) -> Bool {
    if lhs._accel != rhs._accel {return false}
    if lhs._gyro != rhs._gyro {return false}
    if lhs._mag != rhs._mag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_Vector3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Vector3"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}x\0\u{1}y\0\u{1}z\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.y) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.z) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.x, fieldNumber: 1)
    }
    if self.y.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.y, fieldNumber: 2)
    }
    if self.z.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.z, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_Vector3, rhs: Mentraos_Ble_Vector3) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_ButtonEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ButtonEvent"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}button\0\u{1}event\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.button) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.event) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.button != .leftBack {
      try visitor.visitSingularEnumField(value: self.button, fieldNumber: 1)
    }
    if self.event != .singleTap {
      try visitor.visitSingularEnumField(value: self.event, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_ButtonEvent, rhs: Mentraos_Ble_ButtonEvent) -> Bool {
    if lhs.button != rhs.button {return false}
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_ButtonEvent.Button: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0LEFT_BACK\0\u{1}RIGHT_BACK\0")
}

extension Mentraos_Ble_ButtonEvent.Event: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SINGLE_TAP\0\u{1}DOUBLE_TAP\0\u{1}TRIPLE_TAP\0\u{1}LONG_HOLD\0")
}

extension Mentraos_Ble_HeadGesture: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HeadGesture"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}gesture\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.gesture) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.gesture != .nod {
      try visitor.visitSingularEnumField(value: self.gesture, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_HeadGesture, rhs: Mentraos_Ble_HeadGesture) -> Bool {
    if lhs.gesture != rhs.gesture {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_HeadGesture.Gesture: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0NOD\0\u{1}SHAKE\0\u{1}HEAD_UP\0\u{1}HEAD_DOWN\0\u{1}TILT_LEFT\0\u{1}TILT_RIGHT\0")
}

extension Mentraos_Ble_HeadGestureConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HeadGestureConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}gesture\0\u{1}enabled\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.gesture) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.gesture != .nod {
      try visitor.visitSingularEnumField(value: self.gesture, fieldNumber: 1)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_HeadGestureConfig, rhs: Mentraos_Ble_HeadGestureConfig) -> Bool {
    if lhs.gesture != rhs.gesture {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_RestartRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RestartRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_RestartRequest, rhs: Mentraos_Ble_RestartRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_FactoryResetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FactoryResetRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_FactoryResetRequest, rhs: Mentraos_Ble_FactoryResetRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_CacheDashboard: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CacheDashboard"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}dashboard_id\0\u{1}batch\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.dashboardID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._batch) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.dashboardID != 0 {
      try visitor.visitSingularUInt32Field(value: self.dashboardID, fieldNumber: 1)
    }
    try { if let v = self._batch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_CacheDashboard, rhs: Mentraos_Ble_CacheDashboard) -> Bool {
    if lhs.dashboardID != rhs.dashboardID {return false}
    if lhs._batch != rhs._batch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_ClearDashboard: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClearDashboard"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}dashboard_id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.dashboardID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.dashboardID != 0 {
      try visitor.visitSingularUInt32Field(value: self.dashboardID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_ClearDashboard, rhs: Mentraos_Ble_ClearDashboard) -> Bool {
    if lhs.dashboardID != rhs.dashboardID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_ConfigureDashboardTrigger: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConfigureDashboardTrigger"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}dashboard_id\0\u{1}trigger\0\u{3}duration_ms\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.dashboardID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.trigger) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.durationMs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.dashboardID != 0 {
      try visitor.visitSingularUInt32Field(value: self.dashboardID, fieldNumber: 1)
    }
    if self.trigger != .headUp {
      try visitor.visitSingularEnumField(value: self.trigger, fieldNumber: 2)
    }
    if self.durationMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.durationMs, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_ConfigureDashboardTrigger, rhs: Mentraos_Ble_ConfigureDashboardTrigger) -> Bool {
    if lhs.dashboardID != rhs.dashboardID {return false}
    if lhs.trigger != rhs.trigger {return false}
    if lhs.durationMs != rhs.durationMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_ConfigureDashboardTrigger.TriggerType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0HEAD_UP\0\u{1}HEAD_DOWN\0\u{1}BUTTON_TAP\0\u{1}MANUAL_ONLY\0")
}

extension Mentraos_Ble_DashboardShown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DashboardShown"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}dashboard_id\0\u{1}source\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.dashboardID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.source) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.dashboardID != 0 {
      try visitor.visitSingularUInt32Field(value: self.dashboardID, fieldNumber: 1)
    }
    if self.source != .gesture {
      try visitor.visitSingularEnumField(value: self.source, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_DashboardShown, rhs: Mentraos_Ble_DashboardShown) -> Bool {
    if lhs.dashboardID != rhs.dashboardID {return false}
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_DashboardShown.TriggerSource: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0GESTURE\0\u{1}BUTTON\0\u{1}MANUAL\0")
}

extension Mentraos_Ble_VersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VersionRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}msg_id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.msgID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.msgID.isEmpty {
      try visitor.visitSingularStringField(value: self.msgID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_VersionRequest, rhs: Mentraos_Ble_VersionRequest) -> Bool {
    if lhs.msgID != rhs.msgID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mentraos_Ble_VersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VersionResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}msg_id\0\u{1}version\0\u{2}\u{8}commit\0\u{3}build_date\0\u{c}\u{3}\u{1}\u{c}\u{4}\u{1}\u{c}\u{5}\u{1}")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.msgID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.version) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.commit) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.buildDate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.msgID.isEmpty {
      try visitor.visitSingularStringField(value: self.msgID, fieldNumber: 1)
    }
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 2)
    }
    if !self.commit.isEmpty {
      try visitor.visitSingularStringField(value: self.commit, fieldNumber: 10)
    }
    if !self.buildDate.isEmpty {
      try visitor.visitSingularStringField(value: self.buildDate, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mentraos_Ble_VersionResponse, rhs: Mentraos_Ble_VersionResponse) -> Bool {
    if lhs.msgID != rhs.msgID {return false}
    if lhs.version != rhs.version {return false}
    if lhs.commit != rhs.commit {return false}
    if lhs.buildDate != rhs.buildDate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
